// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: riskapi_action_protocal.proto

#ifndef PROTOBUF_riskapi_5faction_5fprotocal_2eproto__INCLUDED
#define PROTOBUF_riskapi_5faction_5fprotocal_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace risk {
class private_topic_info;
class private_topic_infoDefaultTypeInternal;
extern private_topic_infoDefaultTypeInternal _private_topic_info_default_instance_;
class req_add_group;
class req_add_groupDefaultTypeInternal;
extern req_add_groupDefaultTypeInternal _req_add_group_default_instance_;
class req_del_group;
class req_del_groupDefaultTypeInternal;
extern req_del_groupDefaultTypeInternal _req_del_group_default_instance_;
class req_edit_group;
class req_edit_groupDefaultTypeInternal;
extern req_edit_groupDefaultTypeInternal _req_edit_group_default_instance_;
class req_groups;
class req_groupsDefaultTypeInternal;
extern req_groupsDefaultTypeInternal _req_groups_default_instance_;
class req_insert_investors_to_group;
class req_insert_investors_to_groupDefaultTypeInternal;
extern req_insert_investors_to_groupDefaultTypeInternal _req_insert_investors_to_group_default_instance_;
class req_instrument_list;
class req_instrument_listDefaultTypeInternal;
extern req_instrument_listDefaultTypeInternal _req_instrument_list_default_instance_;
class req_margin;
class req_marginDefaultTypeInternal;
extern req_marginDefaultTypeInternal _req_margin_default_instance_;
class req_option_argv;
class req_option_argvDefaultTypeInternal;
extern req_option_argvDefaultTypeInternal _req_option_argv_default_instance_;
class req_order;
class req_orderDefaultTypeInternal;
extern req_orderDefaultTypeInternal _req_order_default_instance_;
class req_position;
class req_positionDefaultTypeInternal;
extern req_positionDefaultTypeInternal _req_position_default_instance_;
class req_remove_investors_from_group;
class req_remove_investors_from_groupDefaultTypeInternal;
extern req_remove_investors_from_groupDefaultTypeInternal _req_remove_investors_from_group_default_instance_;
class req_risker_investor;
class req_risker_investorDefaultTypeInternal;
extern req_risker_investorDefaultTypeInternal _req_risker_investor_default_instance_;
class req_risker_login;
class req_risker_loginDefaultTypeInternal;
extern req_risker_loginDefaultTypeInternal _req_risker_login_default_instance_;
class req_sync_account;
class req_sync_accountDefaultTypeInternal;
extern req_sync_accountDefaultTypeInternal _req_sync_account_default_instance_;
class req_trade;
class req_tradeDefaultTypeInternal;
extern req_tradeDefaultTypeInternal _req_trade_default_instance_;
class req_whatif;
class req_whatifDefaultTypeInternal;
extern req_whatifDefaultTypeInternal _req_whatif_default_instance_;
class sub_option_position_risk;
class sub_option_position_riskDefaultTypeInternal;
extern sub_option_position_riskDefaultTypeInternal _sub_option_position_risk_default_instance_;
class subscribe_margin;
class subscribe_marginDefaultTypeInternal;
extern subscribe_marginDefaultTypeInternal _subscribe_margin_default_instance_;
class subscribe_position;
class subscribe_positionDefaultTypeInternal;
extern subscribe_positionDefaultTypeInternal _subscribe_position_default_instance_;
class subscribe_private_topic;
class subscribe_private_topicDefaultTypeInternal;
extern subscribe_private_topicDefaultTypeInternal _subscribe_private_topic_default_instance_;
class subscribe_quote;
class subscribe_quoteDefaultTypeInternal;
extern subscribe_quoteDefaultTypeInternal _subscribe_quote_default_instance_;
class subscribe_sync_account;
class subscribe_sync_accountDefaultTypeInternal;
extern subscribe_sync_accountDefaultTypeInternal _subscribe_sync_account_default_instance_;
class sys_group;
class sys_groupDefaultTypeInternal;
extern sys_groupDefaultTypeInternal _sys_group_default_instance_;
class unsub_option_position_risk;
class unsub_option_position_riskDefaultTypeInternal;
extern unsub_option_position_riskDefaultTypeInternal _unsub_option_position_risk_default_instance_;
class unsubscribe_margin;
class unsubscribe_marginDefaultTypeInternal;
extern unsubscribe_marginDefaultTypeInternal _unsubscribe_margin_default_instance_;
class unsubscribe_position;
class unsubscribe_positionDefaultTypeInternal;
extern unsubscribe_positionDefaultTypeInternal _unsubscribe_position_default_instance_;
class unsubscribe_private_topic;
class unsubscribe_private_topicDefaultTypeInternal;
extern unsubscribe_private_topicDefaultTypeInternal _unsubscribe_private_topic_default_instance_;
class unsubscribe_quote;
class unsubscribe_quoteDefaultTypeInternal;
extern unsubscribe_quoteDefaultTypeInternal _unsubscribe_quote_default_instance_;
class unsubscribe_sync_account;
class unsubscribe_sync_accountDefaultTypeInternal;
extern unsubscribe_sync_accountDefaultTypeInternal _unsubscribe_sync_account_default_instance_;
}  // namespace risk

namespace risk {

namespace protobuf_riskapi_5faction_5fprotocal_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_riskapi_5faction_5fprotocal_2eproto

// ===================================================================

class req_risker_login : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.req_risker_login) */ {
 public:
  req_risker_login();
  virtual ~req_risker_login();

  req_risker_login(const req_risker_login& from);

  inline req_risker_login& operator=(const req_risker_login& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  req_risker_login(req_risker_login&& from) noexcept
    : req_risker_login() {
    *this = ::std::move(from);
  }

  inline req_risker_login& operator=(req_risker_login&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const req_risker_login& default_instance();

  static inline const req_risker_login* internal_default_instance() {
    return reinterpret_cast<const req_risker_login*>(
               &_req_risker_login_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(req_risker_login* other);
  friend void swap(req_risker_login& a, req_risker_login& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline req_risker_login* New() const PROTOBUF_FINAL { return New(NULL); }

  req_risker_login* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const req_risker_login& from);
  void MergeFrom(const req_risker_login& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(req_risker_login* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string riskerid = 2;
  void clear_riskerid();
  static const int kRiskeridFieldNumber = 2;
  const ::std::string& riskerid() const;
  void set_riskerid(const ::std::string& value);
  #if LANG_CXX11
  void set_riskerid(::std::string&& value);
  #endif
  void set_riskerid(const char* value);
  void set_riskerid(const char* value, size_t size);
  ::std::string* mutable_riskerid();
  ::std::string* release_riskerid();
  void set_allocated_riskerid(::std::string* riskerid);

  // string password = 3;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // int32 requestid = 1;
  void clear_requestid();
  static const int kRequestidFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.req_risker_login)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr riskerid_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::int32 requestid_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class req_instrument_list : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.req_instrument_list) */ {
 public:
  req_instrument_list();
  virtual ~req_instrument_list();

  req_instrument_list(const req_instrument_list& from);

  inline req_instrument_list& operator=(const req_instrument_list& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  req_instrument_list(req_instrument_list&& from) noexcept
    : req_instrument_list() {
    *this = ::std::move(from);
  }

  inline req_instrument_list& operator=(req_instrument_list&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const req_instrument_list& default_instance();

  static inline const req_instrument_list* internal_default_instance() {
    return reinterpret_cast<const req_instrument_list*>(
               &_req_instrument_list_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(req_instrument_list* other);
  friend void swap(req_instrument_list& a, req_instrument_list& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline req_instrument_list* New() const PROTOBUF_FINAL { return New(NULL); }

  req_instrument_list* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const req_instrument_list& from);
  void MergeFrom(const req_instrument_list& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(req_instrument_list* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 requestid = 1;
  void clear_requestid();
  static const int kRequestidFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.req_instrument_list)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 requestid_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class subscribe_quote : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.subscribe_quote) */ {
 public:
  subscribe_quote();
  virtual ~subscribe_quote();

  subscribe_quote(const subscribe_quote& from);

  inline subscribe_quote& operator=(const subscribe_quote& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  subscribe_quote(subscribe_quote&& from) noexcept
    : subscribe_quote() {
    *this = ::std::move(from);
  }

  inline subscribe_quote& operator=(subscribe_quote&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const subscribe_quote& default_instance();

  static inline const subscribe_quote* internal_default_instance() {
    return reinterpret_cast<const subscribe_quote*>(
               &_subscribe_quote_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(subscribe_quote* other);
  friend void swap(subscribe_quote& a, subscribe_quote& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline subscribe_quote* New() const PROTOBUF_FINAL { return New(NULL); }

  subscribe_quote* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const subscribe_quote& from);
  void MergeFrom(const subscribe_quote& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(subscribe_quote* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string instrument = 1;
  int instrument_size() const;
  void clear_instrument();
  static const int kInstrumentFieldNumber = 1;
  const ::std::string& instrument(int index) const;
  ::std::string* mutable_instrument(int index);
  void set_instrument(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_instrument(int index, ::std::string&& value);
  #endif
  void set_instrument(int index, const char* value);
  void set_instrument(int index, const char* value, size_t size);
  ::std::string* add_instrument();
  void add_instrument(const ::std::string& value);
  #if LANG_CXX11
  void add_instrument(::std::string&& value);
  #endif
  void add_instrument(const char* value);
  void add_instrument(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& instrument() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_instrument();

  // @@protoc_insertion_point(class_scope:risk.subscribe_quote)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> instrument_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class unsubscribe_quote : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.unsubscribe_quote) */ {
 public:
  unsubscribe_quote();
  virtual ~unsubscribe_quote();

  unsubscribe_quote(const unsubscribe_quote& from);

  inline unsubscribe_quote& operator=(const unsubscribe_quote& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  unsubscribe_quote(unsubscribe_quote&& from) noexcept
    : unsubscribe_quote() {
    *this = ::std::move(from);
  }

  inline unsubscribe_quote& operator=(unsubscribe_quote&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const unsubscribe_quote& default_instance();

  static inline const unsubscribe_quote* internal_default_instance() {
    return reinterpret_cast<const unsubscribe_quote*>(
               &_unsubscribe_quote_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(unsubscribe_quote* other);
  friend void swap(unsubscribe_quote& a, unsubscribe_quote& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline unsubscribe_quote* New() const PROTOBUF_FINAL { return New(NULL); }

  unsubscribe_quote* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const unsubscribe_quote& from);
  void MergeFrom(const unsubscribe_quote& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(unsubscribe_quote* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string instrument = 1;
  int instrument_size() const;
  void clear_instrument();
  static const int kInstrumentFieldNumber = 1;
  const ::std::string& instrument(int index) const;
  ::std::string* mutable_instrument(int index);
  void set_instrument(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_instrument(int index, ::std::string&& value);
  #endif
  void set_instrument(int index, const char* value);
  void set_instrument(int index, const char* value, size_t size);
  ::std::string* add_instrument();
  void add_instrument(const ::std::string& value);
  #if LANG_CXX11
  void add_instrument(::std::string&& value);
  #endif
  void add_instrument(const char* value);
  void add_instrument(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& instrument() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_instrument();

  // @@protoc_insertion_point(class_scope:risk.unsubscribe_quote)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> instrument_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class req_position : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.req_position) */ {
 public:
  req_position();
  virtual ~req_position();

  req_position(const req_position& from);

  inline req_position& operator=(const req_position& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  req_position(req_position&& from) noexcept
    : req_position() {
    *this = ::std::move(from);
  }

  inline req_position& operator=(req_position&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const req_position& default_instance();

  static inline const req_position* internal_default_instance() {
    return reinterpret_cast<const req_position*>(
               &_req_position_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(req_position* other);
  friend void swap(req_position& a, req_position& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline req_position* New() const PROTOBUF_FINAL { return New(NULL); }

  req_position* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const req_position& from);
  void MergeFrom(const req_position& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(req_position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string investor = 2;
  int investor_size() const;
  void clear_investor();
  static const int kInvestorFieldNumber = 2;
  const ::std::string& investor(int index) const;
  ::std::string* mutable_investor(int index);
  void set_investor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_investor(int index, ::std::string&& value);
  #endif
  void set_investor(int index, const char* value);
  void set_investor(int index, const char* value, size_t size);
  ::std::string* add_investor();
  void add_investor(const ::std::string& value);
  #if LANG_CXX11
  void add_investor(::std::string&& value);
  #endif
  void add_investor(const char* value);
  void add_investor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& investor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_investor();

  // int32 requestid = 1;
  void clear_requestid();
  static const int kRequestidFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.req_position)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> investor_;
  ::google::protobuf::int32 requestid_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class subscribe_position : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.subscribe_position) */ {
 public:
  subscribe_position();
  virtual ~subscribe_position();

  subscribe_position(const subscribe_position& from);

  inline subscribe_position& operator=(const subscribe_position& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  subscribe_position(subscribe_position&& from) noexcept
    : subscribe_position() {
    *this = ::std::move(from);
  }

  inline subscribe_position& operator=(subscribe_position&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const subscribe_position& default_instance();

  static inline const subscribe_position* internal_default_instance() {
    return reinterpret_cast<const subscribe_position*>(
               &_subscribe_position_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(subscribe_position* other);
  friend void swap(subscribe_position& a, subscribe_position& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline subscribe_position* New() const PROTOBUF_FINAL { return New(NULL); }

  subscribe_position* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const subscribe_position& from);
  void MergeFrom(const subscribe_position& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(subscribe_position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string investor = 1;
  int investor_size() const;
  void clear_investor();
  static const int kInvestorFieldNumber = 1;
  const ::std::string& investor(int index) const;
  ::std::string* mutable_investor(int index);
  void set_investor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_investor(int index, ::std::string&& value);
  #endif
  void set_investor(int index, const char* value);
  void set_investor(int index, const char* value, size_t size);
  ::std::string* add_investor();
  void add_investor(const ::std::string& value);
  #if LANG_CXX11
  void add_investor(::std::string&& value);
  #endif
  void add_investor(const char* value);
  void add_investor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& investor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_investor();

  // @@protoc_insertion_point(class_scope:risk.subscribe_position)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> investor_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class unsubscribe_position : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.unsubscribe_position) */ {
 public:
  unsubscribe_position();
  virtual ~unsubscribe_position();

  unsubscribe_position(const unsubscribe_position& from);

  inline unsubscribe_position& operator=(const unsubscribe_position& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  unsubscribe_position(unsubscribe_position&& from) noexcept
    : unsubscribe_position() {
    *this = ::std::move(from);
  }

  inline unsubscribe_position& operator=(unsubscribe_position&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const unsubscribe_position& default_instance();

  static inline const unsubscribe_position* internal_default_instance() {
    return reinterpret_cast<const unsubscribe_position*>(
               &_unsubscribe_position_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(unsubscribe_position* other);
  friend void swap(unsubscribe_position& a, unsubscribe_position& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline unsubscribe_position* New() const PROTOBUF_FINAL { return New(NULL); }

  unsubscribe_position* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const unsubscribe_position& from);
  void MergeFrom(const unsubscribe_position& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(unsubscribe_position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string investor = 1;
  int investor_size() const;
  void clear_investor();
  static const int kInvestorFieldNumber = 1;
  const ::std::string& investor(int index) const;
  ::std::string* mutable_investor(int index);
  void set_investor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_investor(int index, ::std::string&& value);
  #endif
  void set_investor(int index, const char* value);
  void set_investor(int index, const char* value, size_t size);
  ::std::string* add_investor();
  void add_investor(const ::std::string& value);
  #if LANG_CXX11
  void add_investor(::std::string&& value);
  #endif
  void add_investor(const char* value);
  void add_investor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& investor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_investor();

  // @@protoc_insertion_point(class_scope:risk.unsubscribe_position)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> investor_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class req_trade : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.req_trade) */ {
 public:
  req_trade();
  virtual ~req_trade();

  req_trade(const req_trade& from);

  inline req_trade& operator=(const req_trade& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  req_trade(req_trade&& from) noexcept
    : req_trade() {
    *this = ::std::move(from);
  }

  inline req_trade& operator=(req_trade&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const req_trade& default_instance();

  static inline const req_trade* internal_default_instance() {
    return reinterpret_cast<const req_trade*>(
               &_req_trade_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(req_trade* other);
  friend void swap(req_trade& a, req_trade& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline req_trade* New() const PROTOBUF_FINAL { return New(NULL); }

  req_trade* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const req_trade& from);
  void MergeFrom(const req_trade& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(req_trade* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string investor = 2;
  int investor_size() const;
  void clear_investor();
  static const int kInvestorFieldNumber = 2;
  const ::std::string& investor(int index) const;
  ::std::string* mutable_investor(int index);
  void set_investor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_investor(int index, ::std::string&& value);
  #endif
  void set_investor(int index, const char* value);
  void set_investor(int index, const char* value, size_t size);
  ::std::string* add_investor();
  void add_investor(const ::std::string& value);
  #if LANG_CXX11
  void add_investor(::std::string&& value);
  #endif
  void add_investor(const char* value);
  void add_investor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& investor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_investor();

  // int32 requestid = 1;
  void clear_requestid();
  static const int kRequestidFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.req_trade)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> investor_;
  ::google::protobuf::int32 requestid_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class req_order : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.req_order) */ {
 public:
  req_order();
  virtual ~req_order();

  req_order(const req_order& from);

  inline req_order& operator=(const req_order& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  req_order(req_order&& from) noexcept
    : req_order() {
    *this = ::std::move(from);
  }

  inline req_order& operator=(req_order&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const req_order& default_instance();

  static inline const req_order* internal_default_instance() {
    return reinterpret_cast<const req_order*>(
               &_req_order_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(req_order* other);
  friend void swap(req_order& a, req_order& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline req_order* New() const PROTOBUF_FINAL { return New(NULL); }

  req_order* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const req_order& from);
  void MergeFrom(const req_order& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(req_order* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string investor = 2;
  int investor_size() const;
  void clear_investor();
  static const int kInvestorFieldNumber = 2;
  const ::std::string& investor(int index) const;
  ::std::string* mutable_investor(int index);
  void set_investor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_investor(int index, ::std::string&& value);
  #endif
  void set_investor(int index, const char* value);
  void set_investor(int index, const char* value, size_t size);
  ::std::string* add_investor();
  void add_investor(const ::std::string& value);
  #if LANG_CXX11
  void add_investor(::std::string&& value);
  #endif
  void add_investor(const char* value);
  void add_investor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& investor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_investor();

  // int32 requestid = 1;
  void clear_requestid();
  static const int kRequestidFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.req_order)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> investor_;
  ::google::protobuf::int32 requestid_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class private_topic_info : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.private_topic_info) */ {
 public:
  private_topic_info();
  virtual ~private_topic_info();

  private_topic_info(const private_topic_info& from);

  inline private_topic_info& operator=(const private_topic_info& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  private_topic_info(private_topic_info&& from) noexcept
    : private_topic_info() {
    *this = ::std::move(from);
  }

  inline private_topic_info& operator=(private_topic_info&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const private_topic_info& default_instance();

  static inline const private_topic_info* internal_default_instance() {
    return reinterpret_cast<const private_topic_info*>(
               &_private_topic_info_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(private_topic_info* other);
  friend void swap(private_topic_info& a, private_topic_info& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline private_topic_info* New() const PROTOBUF_FINAL { return New(NULL); }

  private_topic_info* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const private_topic_info& from);
  void MergeFrom(const private_topic_info& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(private_topic_info* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string investor = 1;
  void clear_investor();
  static const int kInvestorFieldNumber = 1;
  const ::std::string& investor() const;
  void set_investor(const ::std::string& value);
  #if LANG_CXX11
  void set_investor(::std::string&& value);
  #endif
  void set_investor(const char* value);
  void set_investor(const char* value, size_t size);
  ::std::string* mutable_investor();
  ::std::string* release_investor();
  void set_allocated_investor(::std::string* investor);

  // int32 id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.private_topic_info)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr investor_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class subscribe_private_topic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.subscribe_private_topic) */ {
 public:
  subscribe_private_topic();
  virtual ~subscribe_private_topic();

  subscribe_private_topic(const subscribe_private_topic& from);

  inline subscribe_private_topic& operator=(const subscribe_private_topic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  subscribe_private_topic(subscribe_private_topic&& from) noexcept
    : subscribe_private_topic() {
    *this = ::std::move(from);
  }

  inline subscribe_private_topic& operator=(subscribe_private_topic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const subscribe_private_topic& default_instance();

  static inline const subscribe_private_topic* internal_default_instance() {
    return reinterpret_cast<const subscribe_private_topic*>(
               &_subscribe_private_topic_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(subscribe_private_topic* other);
  friend void swap(subscribe_private_topic& a, subscribe_private_topic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline subscribe_private_topic* New() const PROTOBUF_FINAL { return New(NULL); }

  subscribe_private_topic* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const subscribe_private_topic& from);
  void MergeFrom(const subscribe_private_topic& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(subscribe_private_topic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .risk.private_topic_info field = 1;
  int field_size() const;
  void clear_field();
  static const int kFieldFieldNumber = 1;
  const ::risk::private_topic_info& field(int index) const;
  ::risk::private_topic_info* mutable_field(int index);
  ::risk::private_topic_info* add_field();
  ::google::protobuf::RepeatedPtrField< ::risk::private_topic_info >*
      mutable_field();
  const ::google::protobuf::RepeatedPtrField< ::risk::private_topic_info >&
      field() const;

  // @@protoc_insertion_point(class_scope:risk.subscribe_private_topic)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::risk::private_topic_info > field_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class unsubscribe_private_topic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.unsubscribe_private_topic) */ {
 public:
  unsubscribe_private_topic();
  virtual ~unsubscribe_private_topic();

  unsubscribe_private_topic(const unsubscribe_private_topic& from);

  inline unsubscribe_private_topic& operator=(const unsubscribe_private_topic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  unsubscribe_private_topic(unsubscribe_private_topic&& from) noexcept
    : unsubscribe_private_topic() {
    *this = ::std::move(from);
  }

  inline unsubscribe_private_topic& operator=(unsubscribe_private_topic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const unsubscribe_private_topic& default_instance();

  static inline const unsubscribe_private_topic* internal_default_instance() {
    return reinterpret_cast<const unsubscribe_private_topic*>(
               &_unsubscribe_private_topic_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(unsubscribe_private_topic* other);
  friend void swap(unsubscribe_private_topic& a, unsubscribe_private_topic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline unsubscribe_private_topic* New() const PROTOBUF_FINAL { return New(NULL); }

  unsubscribe_private_topic* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const unsubscribe_private_topic& from);
  void MergeFrom(const unsubscribe_private_topic& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(unsubscribe_private_topic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string investor = 1;
  int investor_size() const;
  void clear_investor();
  static const int kInvestorFieldNumber = 1;
  const ::std::string& investor(int index) const;
  ::std::string* mutable_investor(int index);
  void set_investor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_investor(int index, ::std::string&& value);
  #endif
  void set_investor(int index, const char* value);
  void set_investor(int index, const char* value, size_t size);
  ::std::string* add_investor();
  void add_investor(const ::std::string& value);
  #if LANG_CXX11
  void add_investor(::std::string&& value);
  #endif
  void add_investor(const char* value);
  void add_investor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& investor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_investor();

  // @@protoc_insertion_point(class_scope:risk.unsubscribe_private_topic)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> investor_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class req_sync_account : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.req_sync_account) */ {
 public:
  req_sync_account();
  virtual ~req_sync_account();

  req_sync_account(const req_sync_account& from);

  inline req_sync_account& operator=(const req_sync_account& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  req_sync_account(req_sync_account&& from) noexcept
    : req_sync_account() {
    *this = ::std::move(from);
  }

  inline req_sync_account& operator=(req_sync_account&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const req_sync_account& default_instance();

  static inline const req_sync_account* internal_default_instance() {
    return reinterpret_cast<const req_sync_account*>(
               &_req_sync_account_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(req_sync_account* other);
  friend void swap(req_sync_account& a, req_sync_account& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline req_sync_account* New() const PROTOBUF_FINAL { return New(NULL); }

  req_sync_account* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const req_sync_account& from);
  void MergeFrom(const req_sync_account& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(req_sync_account* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string investor = 2;
  int investor_size() const;
  void clear_investor();
  static const int kInvestorFieldNumber = 2;
  const ::std::string& investor(int index) const;
  ::std::string* mutable_investor(int index);
  void set_investor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_investor(int index, ::std::string&& value);
  #endif
  void set_investor(int index, const char* value);
  void set_investor(int index, const char* value, size_t size);
  ::std::string* add_investor();
  void add_investor(const ::std::string& value);
  #if LANG_CXX11
  void add_investor(::std::string&& value);
  #endif
  void add_investor(const char* value);
  void add_investor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& investor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_investor();

  // int32 requestid = 1;
  void clear_requestid();
  static const int kRequestidFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.req_sync_account)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> investor_;
  ::google::protobuf::int32 requestid_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class subscribe_sync_account : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.subscribe_sync_account) */ {
 public:
  subscribe_sync_account();
  virtual ~subscribe_sync_account();

  subscribe_sync_account(const subscribe_sync_account& from);

  inline subscribe_sync_account& operator=(const subscribe_sync_account& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  subscribe_sync_account(subscribe_sync_account&& from) noexcept
    : subscribe_sync_account() {
    *this = ::std::move(from);
  }

  inline subscribe_sync_account& operator=(subscribe_sync_account&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const subscribe_sync_account& default_instance();

  static inline const subscribe_sync_account* internal_default_instance() {
    return reinterpret_cast<const subscribe_sync_account*>(
               &_subscribe_sync_account_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(subscribe_sync_account* other);
  friend void swap(subscribe_sync_account& a, subscribe_sync_account& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline subscribe_sync_account* New() const PROTOBUF_FINAL { return New(NULL); }

  subscribe_sync_account* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const subscribe_sync_account& from);
  void MergeFrom(const subscribe_sync_account& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(subscribe_sync_account* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string investor = 1;
  int investor_size() const;
  void clear_investor();
  static const int kInvestorFieldNumber = 1;
  const ::std::string& investor(int index) const;
  ::std::string* mutable_investor(int index);
  void set_investor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_investor(int index, ::std::string&& value);
  #endif
  void set_investor(int index, const char* value);
  void set_investor(int index, const char* value, size_t size);
  ::std::string* add_investor();
  void add_investor(const ::std::string& value);
  #if LANG_CXX11
  void add_investor(::std::string&& value);
  #endif
  void add_investor(const char* value);
  void add_investor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& investor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_investor();

  // @@protoc_insertion_point(class_scope:risk.subscribe_sync_account)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> investor_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class unsubscribe_sync_account : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.unsubscribe_sync_account) */ {
 public:
  unsubscribe_sync_account();
  virtual ~unsubscribe_sync_account();

  unsubscribe_sync_account(const unsubscribe_sync_account& from);

  inline unsubscribe_sync_account& operator=(const unsubscribe_sync_account& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  unsubscribe_sync_account(unsubscribe_sync_account&& from) noexcept
    : unsubscribe_sync_account() {
    *this = ::std::move(from);
  }

  inline unsubscribe_sync_account& operator=(unsubscribe_sync_account&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const unsubscribe_sync_account& default_instance();

  static inline const unsubscribe_sync_account* internal_default_instance() {
    return reinterpret_cast<const unsubscribe_sync_account*>(
               &_unsubscribe_sync_account_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(unsubscribe_sync_account* other);
  friend void swap(unsubscribe_sync_account& a, unsubscribe_sync_account& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline unsubscribe_sync_account* New() const PROTOBUF_FINAL { return New(NULL); }

  unsubscribe_sync_account* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const unsubscribe_sync_account& from);
  void MergeFrom(const unsubscribe_sync_account& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(unsubscribe_sync_account* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string investor = 1;
  int investor_size() const;
  void clear_investor();
  static const int kInvestorFieldNumber = 1;
  const ::std::string& investor(int index) const;
  ::std::string* mutable_investor(int index);
  void set_investor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_investor(int index, ::std::string&& value);
  #endif
  void set_investor(int index, const char* value);
  void set_investor(int index, const char* value, size_t size);
  ::std::string* add_investor();
  void add_investor(const ::std::string& value);
  #if LANG_CXX11
  void add_investor(::std::string&& value);
  #endif
  void add_investor(const char* value);
  void add_investor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& investor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_investor();

  // @@protoc_insertion_point(class_scope:risk.unsubscribe_sync_account)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> investor_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class req_margin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.req_margin) */ {
 public:
  req_margin();
  virtual ~req_margin();

  req_margin(const req_margin& from);

  inline req_margin& operator=(const req_margin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  req_margin(req_margin&& from) noexcept
    : req_margin() {
    *this = ::std::move(from);
  }

  inline req_margin& operator=(req_margin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const req_margin& default_instance();

  static inline const req_margin* internal_default_instance() {
    return reinterpret_cast<const req_margin*>(
               &_req_margin_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(req_margin* other);
  friend void swap(req_margin& a, req_margin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline req_margin* New() const PROTOBUF_FINAL { return New(NULL); }

  req_margin* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const req_margin& from);
  void MergeFrom(const req_margin& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(req_margin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string investor = 2;
  int investor_size() const;
  void clear_investor();
  static const int kInvestorFieldNumber = 2;
  const ::std::string& investor(int index) const;
  ::std::string* mutable_investor(int index);
  void set_investor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_investor(int index, ::std::string&& value);
  #endif
  void set_investor(int index, const char* value);
  void set_investor(int index, const char* value, size_t size);
  ::std::string* add_investor();
  void add_investor(const ::std::string& value);
  #if LANG_CXX11
  void add_investor(::std::string&& value);
  #endif
  void add_investor(const char* value);
  void add_investor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& investor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_investor();

  // int32 requestid = 1;
  void clear_requestid();
  static const int kRequestidFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.req_margin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> investor_;
  ::google::protobuf::int32 requestid_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class subscribe_margin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.subscribe_margin) */ {
 public:
  subscribe_margin();
  virtual ~subscribe_margin();

  subscribe_margin(const subscribe_margin& from);

  inline subscribe_margin& operator=(const subscribe_margin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  subscribe_margin(subscribe_margin&& from) noexcept
    : subscribe_margin() {
    *this = ::std::move(from);
  }

  inline subscribe_margin& operator=(subscribe_margin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const subscribe_margin& default_instance();

  static inline const subscribe_margin* internal_default_instance() {
    return reinterpret_cast<const subscribe_margin*>(
               &_subscribe_margin_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(subscribe_margin* other);
  friend void swap(subscribe_margin& a, subscribe_margin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline subscribe_margin* New() const PROTOBUF_FINAL { return New(NULL); }

  subscribe_margin* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const subscribe_margin& from);
  void MergeFrom(const subscribe_margin& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(subscribe_margin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string investor = 1;
  int investor_size() const;
  void clear_investor();
  static const int kInvestorFieldNumber = 1;
  const ::std::string& investor(int index) const;
  ::std::string* mutable_investor(int index);
  void set_investor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_investor(int index, ::std::string&& value);
  #endif
  void set_investor(int index, const char* value);
  void set_investor(int index, const char* value, size_t size);
  ::std::string* add_investor();
  void add_investor(const ::std::string& value);
  #if LANG_CXX11
  void add_investor(::std::string&& value);
  #endif
  void add_investor(const char* value);
  void add_investor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& investor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_investor();

  // @@protoc_insertion_point(class_scope:risk.subscribe_margin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> investor_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class unsubscribe_margin : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.unsubscribe_margin) */ {
 public:
  unsubscribe_margin();
  virtual ~unsubscribe_margin();

  unsubscribe_margin(const unsubscribe_margin& from);

  inline unsubscribe_margin& operator=(const unsubscribe_margin& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  unsubscribe_margin(unsubscribe_margin&& from) noexcept
    : unsubscribe_margin() {
    *this = ::std::move(from);
  }

  inline unsubscribe_margin& operator=(unsubscribe_margin&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const unsubscribe_margin& default_instance();

  static inline const unsubscribe_margin* internal_default_instance() {
    return reinterpret_cast<const unsubscribe_margin*>(
               &_unsubscribe_margin_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(unsubscribe_margin* other);
  friend void swap(unsubscribe_margin& a, unsubscribe_margin& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline unsubscribe_margin* New() const PROTOBUF_FINAL { return New(NULL); }

  unsubscribe_margin* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const unsubscribe_margin& from);
  void MergeFrom(const unsubscribe_margin& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(unsubscribe_margin* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string investor = 1;
  int investor_size() const;
  void clear_investor();
  static const int kInvestorFieldNumber = 1;
  const ::std::string& investor(int index) const;
  ::std::string* mutable_investor(int index);
  void set_investor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_investor(int index, ::std::string&& value);
  #endif
  void set_investor(int index, const char* value);
  void set_investor(int index, const char* value, size_t size);
  ::std::string* add_investor();
  void add_investor(const ::std::string& value);
  #if LANG_CXX11
  void add_investor(::std::string&& value);
  #endif
  void add_investor(const char* value);
  void add_investor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& investor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_investor();

  // @@protoc_insertion_point(class_scope:risk.unsubscribe_margin)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> investor_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class req_risker_investor : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.req_risker_investor) */ {
 public:
  req_risker_investor();
  virtual ~req_risker_investor();

  req_risker_investor(const req_risker_investor& from);

  inline req_risker_investor& operator=(const req_risker_investor& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  req_risker_investor(req_risker_investor&& from) noexcept
    : req_risker_investor() {
    *this = ::std::move(from);
  }

  inline req_risker_investor& operator=(req_risker_investor&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const req_risker_investor& default_instance();

  static inline const req_risker_investor* internal_default_instance() {
    return reinterpret_cast<const req_risker_investor*>(
               &_req_risker_investor_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(req_risker_investor* other);
  friend void swap(req_risker_investor& a, req_risker_investor& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline req_risker_investor* New() const PROTOBUF_FINAL { return New(NULL); }

  req_risker_investor* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const req_risker_investor& from);
  void MergeFrom(const req_risker_investor& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(req_risker_investor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string userid = 2;
  void clear_userid();
  static const int kUseridFieldNumber = 2;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // int32 requestid = 1;
  void clear_requestid();
  static const int kRequestidFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.req_risker_investor)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  ::google::protobuf::int32 requestid_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class sys_group : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.sys_group) */ {
 public:
  sys_group();
  virtual ~sys_group();

  sys_group(const sys_group& from);

  inline sys_group& operator=(const sys_group& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  sys_group(sys_group&& from) noexcept
    : sys_group() {
    *this = ::std::move(from);
  }

  inline sys_group& operator=(sys_group&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const sys_group& default_instance();

  static inline const sys_group* internal_default_instance() {
    return reinterpret_cast<const sys_group*>(
               &_sys_group_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(sys_group* other);
  friend void swap(sys_group& a, sys_group& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline sys_group* New() const PROTOBUF_FINAL { return New(NULL); }

  sys_group* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const sys_group& from);
  void MergeFrom(const sys_group& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(sys_group* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string riskgroupid = 1;
  void clear_riskgroupid();
  static const int kRiskgroupidFieldNumber = 1;
  const ::std::string& riskgroupid() const;
  void set_riskgroupid(const ::std::string& value);
  #if LANG_CXX11
  void set_riskgroupid(::std::string&& value);
  #endif
  void set_riskgroupid(const char* value);
  void set_riskgroupid(const char* value, size_t size);
  ::std::string* mutable_riskgroupid();
  ::std::string* release_riskgroupid();
  void set_allocated_riskgroupid(::std::string* riskgroupid);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string desc = 3;
  void clear_desc();
  static const int kDescFieldNumber = 3;
  const ::std::string& desc() const;
  void set_desc(const ::std::string& value);
  #if LANG_CXX11
  void set_desc(::std::string&& value);
  #endif
  void set_desc(const char* value);
  void set_desc(const char* value, size_t size);
  ::std::string* mutable_desc();
  ::std::string* release_desc();
  void set_allocated_desc(::std::string* desc);

  // @@protoc_insertion_point(class_scope:risk.sys_group)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr riskgroupid_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr desc_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class req_groups : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.req_groups) */ {
 public:
  req_groups();
  virtual ~req_groups();

  req_groups(const req_groups& from);

  inline req_groups& operator=(const req_groups& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  req_groups(req_groups&& from) noexcept
    : req_groups() {
    *this = ::std::move(from);
  }

  inline req_groups& operator=(req_groups&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const req_groups& default_instance();

  static inline const req_groups* internal_default_instance() {
    return reinterpret_cast<const req_groups*>(
               &_req_groups_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(req_groups* other);
  friend void swap(req_groups& a, req_groups& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline req_groups* New() const PROTOBUF_FINAL { return New(NULL); }

  req_groups* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const req_groups& from);
  void MergeFrom(const req_groups& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(req_groups* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string userid = 2;
  void clear_userid();
  static const int kUseridFieldNumber = 2;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // int32 requestid = 1;
  void clear_requestid();
  static const int kRequestidFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.req_groups)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  ::google::protobuf::int32 requestid_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class req_add_group : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.req_add_group) */ {
 public:
  req_add_group();
  virtual ~req_add_group();

  req_add_group(const req_add_group& from);

  inline req_add_group& operator=(const req_add_group& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  req_add_group(req_add_group&& from) noexcept
    : req_add_group() {
    *this = ::std::move(from);
  }

  inline req_add_group& operator=(req_add_group&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const req_add_group& default_instance();

  static inline const req_add_group* internal_default_instance() {
    return reinterpret_cast<const req_add_group*>(
               &_req_add_group_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(req_add_group* other);
  friend void swap(req_add_group& a, req_add_group& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline req_add_group* New() const PROTOBUF_FINAL { return New(NULL); }

  req_add_group* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const req_add_group& from);
  void MergeFrom(const req_add_group& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(req_add_group* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string userid = 2;
  void clear_userid();
  static const int kUseridFieldNumber = 2;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // .risk.sys_group group = 3;
  bool has_group() const;
  void clear_group();
  static const int kGroupFieldNumber = 3;
  const ::risk::sys_group& group() const;
  ::risk::sys_group* mutable_group();
  ::risk::sys_group* release_group();
  void set_allocated_group(::risk::sys_group* group);

  // int32 requestid = 1;
  void clear_requestid();
  static const int kRequestidFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.req_add_group)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  ::risk::sys_group* group_;
  ::google::protobuf::int32 requestid_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class req_del_group : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.req_del_group) */ {
 public:
  req_del_group();
  virtual ~req_del_group();

  req_del_group(const req_del_group& from);

  inline req_del_group& operator=(const req_del_group& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  req_del_group(req_del_group&& from) noexcept
    : req_del_group() {
    *this = ::std::move(from);
  }

  inline req_del_group& operator=(req_del_group&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const req_del_group& default_instance();

  static inline const req_del_group* internal_default_instance() {
    return reinterpret_cast<const req_del_group*>(
               &_req_del_group_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(req_del_group* other);
  friend void swap(req_del_group& a, req_del_group& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline req_del_group* New() const PROTOBUF_FINAL { return New(NULL); }

  req_del_group* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const req_del_group& from);
  void MergeFrom(const req_del_group& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(req_del_group* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string userid = 2;
  void clear_userid();
  static const int kUseridFieldNumber = 2;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // string riskgroupid = 3;
  void clear_riskgroupid();
  static const int kRiskgroupidFieldNumber = 3;
  const ::std::string& riskgroupid() const;
  void set_riskgroupid(const ::std::string& value);
  #if LANG_CXX11
  void set_riskgroupid(::std::string&& value);
  #endif
  void set_riskgroupid(const char* value);
  void set_riskgroupid(const char* value, size_t size);
  ::std::string* mutable_riskgroupid();
  ::std::string* release_riskgroupid();
  void set_allocated_riskgroupid(::std::string* riskgroupid);

  // int32 requestid = 1;
  void clear_requestid();
  static const int kRequestidFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.req_del_group)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  ::google::protobuf::internal::ArenaStringPtr riskgroupid_;
  ::google::protobuf::int32 requestid_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class req_edit_group : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.req_edit_group) */ {
 public:
  req_edit_group();
  virtual ~req_edit_group();

  req_edit_group(const req_edit_group& from);

  inline req_edit_group& operator=(const req_edit_group& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  req_edit_group(req_edit_group&& from) noexcept
    : req_edit_group() {
    *this = ::std::move(from);
  }

  inline req_edit_group& operator=(req_edit_group&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const req_edit_group& default_instance();

  static inline const req_edit_group* internal_default_instance() {
    return reinterpret_cast<const req_edit_group*>(
               &_req_edit_group_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(req_edit_group* other);
  friend void swap(req_edit_group& a, req_edit_group& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline req_edit_group* New() const PROTOBUF_FINAL { return New(NULL); }

  req_edit_group* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const req_edit_group& from);
  void MergeFrom(const req_edit_group& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(req_edit_group* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string userid = 2;
  void clear_userid();
  static const int kUseridFieldNumber = 2;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // .risk.sys_group group = 3;
  bool has_group() const;
  void clear_group();
  static const int kGroupFieldNumber = 3;
  const ::risk::sys_group& group() const;
  ::risk::sys_group* mutable_group();
  ::risk::sys_group* release_group();
  void set_allocated_group(::risk::sys_group* group);

  // int32 requestid = 1;
  void clear_requestid();
  static const int kRequestidFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.req_edit_group)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  ::risk::sys_group* group_;
  ::google::protobuf::int32 requestid_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class req_insert_investors_to_group : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.req_insert_investors_to_group) */ {
 public:
  req_insert_investors_to_group();
  virtual ~req_insert_investors_to_group();

  req_insert_investors_to_group(const req_insert_investors_to_group& from);

  inline req_insert_investors_to_group& operator=(const req_insert_investors_to_group& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  req_insert_investors_to_group(req_insert_investors_to_group&& from) noexcept
    : req_insert_investors_to_group() {
    *this = ::std::move(from);
  }

  inline req_insert_investors_to_group& operator=(req_insert_investors_to_group&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const req_insert_investors_to_group& default_instance();

  static inline const req_insert_investors_to_group* internal_default_instance() {
    return reinterpret_cast<const req_insert_investors_to_group*>(
               &_req_insert_investors_to_group_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(req_insert_investors_to_group* other);
  friend void swap(req_insert_investors_to_group& a, req_insert_investors_to_group& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline req_insert_investors_to_group* New() const PROTOBUF_FINAL { return New(NULL); }

  req_insert_investors_to_group* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const req_insert_investors_to_group& from);
  void MergeFrom(const req_insert_investors_to_group& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(req_insert_investors_to_group* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string investor = 4;
  int investor_size() const;
  void clear_investor();
  static const int kInvestorFieldNumber = 4;
  const ::std::string& investor(int index) const;
  ::std::string* mutable_investor(int index);
  void set_investor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_investor(int index, ::std::string&& value);
  #endif
  void set_investor(int index, const char* value);
  void set_investor(int index, const char* value, size_t size);
  ::std::string* add_investor();
  void add_investor(const ::std::string& value);
  #if LANG_CXX11
  void add_investor(::std::string&& value);
  #endif
  void add_investor(const char* value);
  void add_investor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& investor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_investor();

  // string userid = 2;
  void clear_userid();
  static const int kUseridFieldNumber = 2;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // string riskgroupid = 3;
  void clear_riskgroupid();
  static const int kRiskgroupidFieldNumber = 3;
  const ::std::string& riskgroupid() const;
  void set_riskgroupid(const ::std::string& value);
  #if LANG_CXX11
  void set_riskgroupid(::std::string&& value);
  #endif
  void set_riskgroupid(const char* value);
  void set_riskgroupid(const char* value, size_t size);
  ::std::string* mutable_riskgroupid();
  ::std::string* release_riskgroupid();
  void set_allocated_riskgroupid(::std::string* riskgroupid);

  // int32 requestid = 1;
  void clear_requestid();
  static const int kRequestidFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.req_insert_investors_to_group)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> investor_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  ::google::protobuf::internal::ArenaStringPtr riskgroupid_;
  ::google::protobuf::int32 requestid_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class req_remove_investors_from_group : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.req_remove_investors_from_group) */ {
 public:
  req_remove_investors_from_group();
  virtual ~req_remove_investors_from_group();

  req_remove_investors_from_group(const req_remove_investors_from_group& from);

  inline req_remove_investors_from_group& operator=(const req_remove_investors_from_group& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  req_remove_investors_from_group(req_remove_investors_from_group&& from) noexcept
    : req_remove_investors_from_group() {
    *this = ::std::move(from);
  }

  inline req_remove_investors_from_group& operator=(req_remove_investors_from_group&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const req_remove_investors_from_group& default_instance();

  static inline const req_remove_investors_from_group* internal_default_instance() {
    return reinterpret_cast<const req_remove_investors_from_group*>(
               &_req_remove_investors_from_group_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(req_remove_investors_from_group* other);
  friend void swap(req_remove_investors_from_group& a, req_remove_investors_from_group& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline req_remove_investors_from_group* New() const PROTOBUF_FINAL { return New(NULL); }

  req_remove_investors_from_group* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const req_remove_investors_from_group& from);
  void MergeFrom(const req_remove_investors_from_group& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(req_remove_investors_from_group* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string investor = 4;
  int investor_size() const;
  void clear_investor();
  static const int kInvestorFieldNumber = 4;
  const ::std::string& investor(int index) const;
  ::std::string* mutable_investor(int index);
  void set_investor(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_investor(int index, ::std::string&& value);
  #endif
  void set_investor(int index, const char* value);
  void set_investor(int index, const char* value, size_t size);
  ::std::string* add_investor();
  void add_investor(const ::std::string& value);
  #if LANG_CXX11
  void add_investor(::std::string&& value);
  #endif
  void add_investor(const char* value);
  void add_investor(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& investor() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_investor();

  // string userid = 2;
  void clear_userid();
  static const int kUseridFieldNumber = 2;
  const ::std::string& userid() const;
  void set_userid(const ::std::string& value);
  #if LANG_CXX11
  void set_userid(::std::string&& value);
  #endif
  void set_userid(const char* value);
  void set_userid(const char* value, size_t size);
  ::std::string* mutable_userid();
  ::std::string* release_userid();
  void set_allocated_userid(::std::string* userid);

  // string riskgroupid = 3;
  void clear_riskgroupid();
  static const int kRiskgroupidFieldNumber = 3;
  const ::std::string& riskgroupid() const;
  void set_riskgroupid(const ::std::string& value);
  #if LANG_CXX11
  void set_riskgroupid(::std::string&& value);
  #endif
  void set_riskgroupid(const char* value);
  void set_riskgroupid(const char* value, size_t size);
  ::std::string* mutable_riskgroupid();
  ::std::string* release_riskgroupid();
  void set_allocated_riskgroupid(::std::string* riskgroupid);

  // int32 requestid = 1;
  void clear_requestid();
  static const int kRequestidFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.req_remove_investors_from_group)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> investor_;
  ::google::protobuf::internal::ArenaStringPtr userid_;
  ::google::protobuf::internal::ArenaStringPtr riskgroupid_;
  ::google::protobuf::int32 requestid_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class sub_option_position_risk : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.sub_option_position_risk) */ {
 public:
  sub_option_position_risk();
  virtual ~sub_option_position_risk();

  sub_option_position_risk(const sub_option_position_risk& from);

  inline sub_option_position_risk& operator=(const sub_option_position_risk& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  sub_option_position_risk(sub_option_position_risk&& from) noexcept
    : sub_option_position_risk() {
    *this = ::std::move(from);
  }

  inline sub_option_position_risk& operator=(sub_option_position_risk&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const sub_option_position_risk& default_instance();

  static inline const sub_option_position_risk* internal_default_instance() {
    return reinterpret_cast<const sub_option_position_risk*>(
               &_sub_option_position_risk_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(sub_option_position_risk* other);
  friend void swap(sub_option_position_risk& a, sub_option_position_risk& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline sub_option_position_risk* New() const PROTOBUF_FINAL { return New(NULL); }

  sub_option_position_risk* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const sub_option_position_risk& from);
  void MergeFrom(const sub_option_position_risk& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(sub_option_position_risk* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string instrument = 2;
  int instrument_size() const;
  void clear_instrument();
  static const int kInstrumentFieldNumber = 2;
  const ::std::string& instrument(int index) const;
  ::std::string* mutable_instrument(int index);
  void set_instrument(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_instrument(int index, ::std::string&& value);
  #endif
  void set_instrument(int index, const char* value);
  void set_instrument(int index, const char* value, size_t size);
  ::std::string* add_instrument();
  void add_instrument(const ::std::string& value);
  #if LANG_CXX11
  void add_instrument(::std::string&& value);
  #endif
  void add_instrument(const char* value);
  void add_instrument(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& instrument() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_instrument();

  // int32 model = 1;
  void clear_model();
  static const int kModelFieldNumber = 1;
  ::google::protobuf::int32 model() const;
  void set_model(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.sub_option_position_risk)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> instrument_;
  ::google::protobuf::int32 model_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class unsub_option_position_risk : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.unsub_option_position_risk) */ {
 public:
  unsub_option_position_risk();
  virtual ~unsub_option_position_risk();

  unsub_option_position_risk(const unsub_option_position_risk& from);

  inline unsub_option_position_risk& operator=(const unsub_option_position_risk& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  unsub_option_position_risk(unsub_option_position_risk&& from) noexcept
    : unsub_option_position_risk() {
    *this = ::std::move(from);
  }

  inline unsub_option_position_risk& operator=(unsub_option_position_risk&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const unsub_option_position_risk& default_instance();

  static inline const unsub_option_position_risk* internal_default_instance() {
    return reinterpret_cast<const unsub_option_position_risk*>(
               &_unsub_option_position_risk_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(unsub_option_position_risk* other);
  friend void swap(unsub_option_position_risk& a, unsub_option_position_risk& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline unsub_option_position_risk* New() const PROTOBUF_FINAL { return New(NULL); }

  unsub_option_position_risk* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const unsub_option_position_risk& from);
  void MergeFrom(const unsub_option_position_risk& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(unsub_option_position_risk* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string instrument = 2;
  int instrument_size() const;
  void clear_instrument();
  static const int kInstrumentFieldNumber = 2;
  const ::std::string& instrument(int index) const;
  ::std::string* mutable_instrument(int index);
  void set_instrument(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_instrument(int index, ::std::string&& value);
  #endif
  void set_instrument(int index, const char* value);
  void set_instrument(int index, const char* value, size_t size);
  ::std::string* add_instrument();
  void add_instrument(const ::std::string& value);
  #if LANG_CXX11
  void add_instrument(::std::string&& value);
  #endif
  void add_instrument(const char* value);
  void add_instrument(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& instrument() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_instrument();

  // int32 model = 1;
  void clear_model();
  static const int kModelFieldNumber = 1;
  ::google::protobuf::int32 model() const;
  void set_model(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.unsub_option_position_risk)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> instrument_;
  ::google::protobuf::int32 model_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class req_whatif : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.req_whatif) */ {
 public:
  req_whatif();
  virtual ~req_whatif();

  req_whatif(const req_whatif& from);

  inline req_whatif& operator=(const req_whatif& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  req_whatif(req_whatif&& from) noexcept
    : req_whatif() {
    *this = ::std::move(from);
  }

  inline req_whatif& operator=(req_whatif&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const req_whatif& default_instance();

  static inline const req_whatif* internal_default_instance() {
    return reinterpret_cast<const req_whatif*>(
               &_req_whatif_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(req_whatif* other);
  friend void swap(req_whatif& a, req_whatif& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline req_whatif* New() const PROTOBUF_FINAL { return New(NULL); }

  req_whatif* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const req_whatif& from);
  void MergeFrom(const req_whatif& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(req_whatif* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string instrument = 4;
  void clear_instrument();
  static const int kInstrumentFieldNumber = 4;
  const ::std::string& instrument() const;
  void set_instrument(const ::std::string& value);
  #if LANG_CXX11
  void set_instrument(::std::string&& value);
  #endif
  void set_instrument(const char* value);
  void set_instrument(const char* value, size_t size);
  ::std::string* mutable_instrument();
  ::std::string* release_instrument();
  void set_allocated_instrument(::std::string* instrument);

  // int32 requestid = 1;
  void clear_requestid();
  static const int kRequestidFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // int32 type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // double range = 5;
  void clear_range();
  static const int kRangeFieldNumber = 5;
  double range() const;
  void set_range(double value);

  // double base_value = 6;
  void clear_base_value();
  static const int kBaseValueFieldNumber = 6;
  double base_value() const;
  void set_base_value(double value);

  // int32 model = 3;
  void clear_model();
  static const int kModelFieldNumber = 3;
  ::google::protobuf::int32 model() const;
  void set_model(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.req_whatif)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr instrument_;
  ::google::protobuf::int32 requestid_;
  ::google::protobuf::int32 type_;
  double range_;
  double base_value_;
  ::google::protobuf::int32 model_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class req_option_argv : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:risk.req_option_argv) */ {
 public:
  req_option_argv();
  virtual ~req_option_argv();

  req_option_argv(const req_option_argv& from);

  inline req_option_argv& operator=(const req_option_argv& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  req_option_argv(req_option_argv&& from) noexcept
    : req_option_argv() {
    *this = ::std::move(from);
  }

  inline req_option_argv& operator=(req_option_argv&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const req_option_argv& default_instance();

  static inline const req_option_argv* internal_default_instance() {
    return reinterpret_cast<const req_option_argv*>(
               &_req_option_argv_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(req_option_argv* other);
  friend void swap(req_option_argv& a, req_option_argv& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline req_option_argv* New() const PROTOBUF_FINAL { return New(NULL); }

  req_option_argv* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const req_option_argv& from);
  void MergeFrom(const req_option_argv& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(req_option_argv* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 requestid = 1;
  void clear_requestid();
  static const int kRequestidFieldNumber = 1;
  ::google::protobuf::int32 requestid() const;
  void set_requestid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:risk.req_option_argv)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 requestid_;
  mutable int _cached_size_;
  friend struct protobuf_riskapi_5faction_5fprotocal_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// req_risker_login

// int32 requestid = 1;
inline void req_risker_login::clear_requestid() {
  requestid_ = 0;
}
inline ::google::protobuf::int32 req_risker_login::requestid() const {
  // @@protoc_insertion_point(field_get:risk.req_risker_login.requestid)
  return requestid_;
}
inline void req_risker_login::set_requestid(::google::protobuf::int32 value) {
  
  requestid_ = value;
  // @@protoc_insertion_point(field_set:risk.req_risker_login.requestid)
}

// string riskerid = 2;
inline void req_risker_login::clear_riskerid() {
  riskerid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& req_risker_login::riskerid() const {
  // @@protoc_insertion_point(field_get:risk.req_risker_login.riskerid)
  return riskerid_.GetNoArena();
}
inline void req_risker_login::set_riskerid(const ::std::string& value) {
  
  riskerid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.req_risker_login.riskerid)
}
#if LANG_CXX11
inline void req_risker_login::set_riskerid(::std::string&& value) {
  
  riskerid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.req_risker_login.riskerid)
}
#endif
inline void req_risker_login::set_riskerid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  riskerid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.req_risker_login.riskerid)
}
inline void req_risker_login::set_riskerid(const char* value, size_t size) {
  
  riskerid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.req_risker_login.riskerid)
}
inline ::std::string* req_risker_login::mutable_riskerid() {
  
  // @@protoc_insertion_point(field_mutable:risk.req_risker_login.riskerid)
  return riskerid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* req_risker_login::release_riskerid() {
  // @@protoc_insertion_point(field_release:risk.req_risker_login.riskerid)
  
  return riskerid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void req_risker_login::set_allocated_riskerid(::std::string* riskerid) {
  if (riskerid != NULL) {
    
  } else {
    
  }
  riskerid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), riskerid);
  // @@protoc_insertion_point(field_set_allocated:risk.req_risker_login.riskerid)
}

// string password = 3;
inline void req_risker_login::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& req_risker_login::password() const {
  // @@protoc_insertion_point(field_get:risk.req_risker_login.password)
  return password_.GetNoArena();
}
inline void req_risker_login::set_password(const ::std::string& value) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.req_risker_login.password)
}
#if LANG_CXX11
inline void req_risker_login::set_password(::std::string&& value) {
  
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.req_risker_login.password)
}
#endif
inline void req_risker_login::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.req_risker_login.password)
}
inline void req_risker_login::set_password(const char* value, size_t size) {
  
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.req_risker_login.password)
}
inline ::std::string* req_risker_login::mutable_password() {
  
  // @@protoc_insertion_point(field_mutable:risk.req_risker_login.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* req_risker_login::release_password() {
  // @@protoc_insertion_point(field_release:risk.req_risker_login.password)
  
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void req_risker_login::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    
  } else {
    
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:risk.req_risker_login.password)
}

// -------------------------------------------------------------------

// req_instrument_list

// int32 requestid = 1;
inline void req_instrument_list::clear_requestid() {
  requestid_ = 0;
}
inline ::google::protobuf::int32 req_instrument_list::requestid() const {
  // @@protoc_insertion_point(field_get:risk.req_instrument_list.requestid)
  return requestid_;
}
inline void req_instrument_list::set_requestid(::google::protobuf::int32 value) {
  
  requestid_ = value;
  // @@protoc_insertion_point(field_set:risk.req_instrument_list.requestid)
}

// -------------------------------------------------------------------

// subscribe_quote

// repeated string instrument = 1;
inline int subscribe_quote::instrument_size() const {
  return instrument_.size();
}
inline void subscribe_quote::clear_instrument() {
  instrument_.Clear();
}
inline const ::std::string& subscribe_quote::instrument(int index) const {
  // @@protoc_insertion_point(field_get:risk.subscribe_quote.instrument)
  return instrument_.Get(index);
}
inline ::std::string* subscribe_quote::mutable_instrument(int index) {
  // @@protoc_insertion_point(field_mutable:risk.subscribe_quote.instrument)
  return instrument_.Mutable(index);
}
inline void subscribe_quote::set_instrument(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.subscribe_quote.instrument)
  instrument_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void subscribe_quote::set_instrument(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.subscribe_quote.instrument)
  instrument_.Mutable(index)->assign(std::move(value));
}
#endif
inline void subscribe_quote::set_instrument(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  instrument_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.subscribe_quote.instrument)
}
inline void subscribe_quote::set_instrument(int index, const char* value, size_t size) {
  instrument_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.subscribe_quote.instrument)
}
inline ::std::string* subscribe_quote::add_instrument() {
  // @@protoc_insertion_point(field_add_mutable:risk.subscribe_quote.instrument)
  return instrument_.Add();
}
inline void subscribe_quote::add_instrument(const ::std::string& value) {
  instrument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.subscribe_quote.instrument)
}
#if LANG_CXX11
inline void subscribe_quote::add_instrument(::std::string&& value) {
  instrument_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.subscribe_quote.instrument)
}
#endif
inline void subscribe_quote::add_instrument(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  instrument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.subscribe_quote.instrument)
}
inline void subscribe_quote::add_instrument(const char* value, size_t size) {
  instrument_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.subscribe_quote.instrument)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
subscribe_quote::instrument() const {
  // @@protoc_insertion_point(field_list:risk.subscribe_quote.instrument)
  return instrument_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
subscribe_quote::mutable_instrument() {
  // @@protoc_insertion_point(field_mutable_list:risk.subscribe_quote.instrument)
  return &instrument_;
}

// -------------------------------------------------------------------

// unsubscribe_quote

// repeated string instrument = 1;
inline int unsubscribe_quote::instrument_size() const {
  return instrument_.size();
}
inline void unsubscribe_quote::clear_instrument() {
  instrument_.Clear();
}
inline const ::std::string& unsubscribe_quote::instrument(int index) const {
  // @@protoc_insertion_point(field_get:risk.unsubscribe_quote.instrument)
  return instrument_.Get(index);
}
inline ::std::string* unsubscribe_quote::mutable_instrument(int index) {
  // @@protoc_insertion_point(field_mutable:risk.unsubscribe_quote.instrument)
  return instrument_.Mutable(index);
}
inline void unsubscribe_quote::set_instrument(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.unsubscribe_quote.instrument)
  instrument_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void unsubscribe_quote::set_instrument(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.unsubscribe_quote.instrument)
  instrument_.Mutable(index)->assign(std::move(value));
}
#endif
inline void unsubscribe_quote::set_instrument(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  instrument_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.unsubscribe_quote.instrument)
}
inline void unsubscribe_quote::set_instrument(int index, const char* value, size_t size) {
  instrument_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.unsubscribe_quote.instrument)
}
inline ::std::string* unsubscribe_quote::add_instrument() {
  // @@protoc_insertion_point(field_add_mutable:risk.unsubscribe_quote.instrument)
  return instrument_.Add();
}
inline void unsubscribe_quote::add_instrument(const ::std::string& value) {
  instrument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.unsubscribe_quote.instrument)
}
#if LANG_CXX11
inline void unsubscribe_quote::add_instrument(::std::string&& value) {
  instrument_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.unsubscribe_quote.instrument)
}
#endif
inline void unsubscribe_quote::add_instrument(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  instrument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.unsubscribe_quote.instrument)
}
inline void unsubscribe_quote::add_instrument(const char* value, size_t size) {
  instrument_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.unsubscribe_quote.instrument)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
unsubscribe_quote::instrument() const {
  // @@protoc_insertion_point(field_list:risk.unsubscribe_quote.instrument)
  return instrument_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
unsubscribe_quote::mutable_instrument() {
  // @@protoc_insertion_point(field_mutable_list:risk.unsubscribe_quote.instrument)
  return &instrument_;
}

// -------------------------------------------------------------------

// req_position

// int32 requestid = 1;
inline void req_position::clear_requestid() {
  requestid_ = 0;
}
inline ::google::protobuf::int32 req_position::requestid() const {
  // @@protoc_insertion_point(field_get:risk.req_position.requestid)
  return requestid_;
}
inline void req_position::set_requestid(::google::protobuf::int32 value) {
  
  requestid_ = value;
  // @@protoc_insertion_point(field_set:risk.req_position.requestid)
}

// repeated string investor = 2;
inline int req_position::investor_size() const {
  return investor_.size();
}
inline void req_position::clear_investor() {
  investor_.Clear();
}
inline const ::std::string& req_position::investor(int index) const {
  // @@protoc_insertion_point(field_get:risk.req_position.investor)
  return investor_.Get(index);
}
inline ::std::string* req_position::mutable_investor(int index) {
  // @@protoc_insertion_point(field_mutable:risk.req_position.investor)
  return investor_.Mutable(index);
}
inline void req_position::set_investor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.req_position.investor)
  investor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void req_position::set_investor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.req_position.investor)
  investor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void req_position::set_investor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.req_position.investor)
}
inline void req_position::set_investor(int index, const char* value, size_t size) {
  investor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.req_position.investor)
}
inline ::std::string* req_position::add_investor() {
  // @@protoc_insertion_point(field_add_mutable:risk.req_position.investor)
  return investor_.Add();
}
inline void req_position::add_investor(const ::std::string& value) {
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.req_position.investor)
}
#if LANG_CXX11
inline void req_position::add_investor(::std::string&& value) {
  investor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.req_position.investor)
}
#endif
inline void req_position::add_investor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.req_position.investor)
}
inline void req_position::add_investor(const char* value, size_t size) {
  investor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.req_position.investor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
req_position::investor() const {
  // @@protoc_insertion_point(field_list:risk.req_position.investor)
  return investor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
req_position::mutable_investor() {
  // @@protoc_insertion_point(field_mutable_list:risk.req_position.investor)
  return &investor_;
}

// -------------------------------------------------------------------

// subscribe_position

// repeated string investor = 1;
inline int subscribe_position::investor_size() const {
  return investor_.size();
}
inline void subscribe_position::clear_investor() {
  investor_.Clear();
}
inline const ::std::string& subscribe_position::investor(int index) const {
  // @@protoc_insertion_point(field_get:risk.subscribe_position.investor)
  return investor_.Get(index);
}
inline ::std::string* subscribe_position::mutable_investor(int index) {
  // @@protoc_insertion_point(field_mutable:risk.subscribe_position.investor)
  return investor_.Mutable(index);
}
inline void subscribe_position::set_investor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.subscribe_position.investor)
  investor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void subscribe_position::set_investor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.subscribe_position.investor)
  investor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void subscribe_position::set_investor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.subscribe_position.investor)
}
inline void subscribe_position::set_investor(int index, const char* value, size_t size) {
  investor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.subscribe_position.investor)
}
inline ::std::string* subscribe_position::add_investor() {
  // @@protoc_insertion_point(field_add_mutable:risk.subscribe_position.investor)
  return investor_.Add();
}
inline void subscribe_position::add_investor(const ::std::string& value) {
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.subscribe_position.investor)
}
#if LANG_CXX11
inline void subscribe_position::add_investor(::std::string&& value) {
  investor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.subscribe_position.investor)
}
#endif
inline void subscribe_position::add_investor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.subscribe_position.investor)
}
inline void subscribe_position::add_investor(const char* value, size_t size) {
  investor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.subscribe_position.investor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
subscribe_position::investor() const {
  // @@protoc_insertion_point(field_list:risk.subscribe_position.investor)
  return investor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
subscribe_position::mutable_investor() {
  // @@protoc_insertion_point(field_mutable_list:risk.subscribe_position.investor)
  return &investor_;
}

// -------------------------------------------------------------------

// unsubscribe_position

// repeated string investor = 1;
inline int unsubscribe_position::investor_size() const {
  return investor_.size();
}
inline void unsubscribe_position::clear_investor() {
  investor_.Clear();
}
inline const ::std::string& unsubscribe_position::investor(int index) const {
  // @@protoc_insertion_point(field_get:risk.unsubscribe_position.investor)
  return investor_.Get(index);
}
inline ::std::string* unsubscribe_position::mutable_investor(int index) {
  // @@protoc_insertion_point(field_mutable:risk.unsubscribe_position.investor)
  return investor_.Mutable(index);
}
inline void unsubscribe_position::set_investor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.unsubscribe_position.investor)
  investor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void unsubscribe_position::set_investor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.unsubscribe_position.investor)
  investor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void unsubscribe_position::set_investor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.unsubscribe_position.investor)
}
inline void unsubscribe_position::set_investor(int index, const char* value, size_t size) {
  investor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.unsubscribe_position.investor)
}
inline ::std::string* unsubscribe_position::add_investor() {
  // @@protoc_insertion_point(field_add_mutable:risk.unsubscribe_position.investor)
  return investor_.Add();
}
inline void unsubscribe_position::add_investor(const ::std::string& value) {
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.unsubscribe_position.investor)
}
#if LANG_CXX11
inline void unsubscribe_position::add_investor(::std::string&& value) {
  investor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.unsubscribe_position.investor)
}
#endif
inline void unsubscribe_position::add_investor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.unsubscribe_position.investor)
}
inline void unsubscribe_position::add_investor(const char* value, size_t size) {
  investor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.unsubscribe_position.investor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
unsubscribe_position::investor() const {
  // @@protoc_insertion_point(field_list:risk.unsubscribe_position.investor)
  return investor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
unsubscribe_position::mutable_investor() {
  // @@protoc_insertion_point(field_mutable_list:risk.unsubscribe_position.investor)
  return &investor_;
}

// -------------------------------------------------------------------

// req_trade

// int32 requestid = 1;
inline void req_trade::clear_requestid() {
  requestid_ = 0;
}
inline ::google::protobuf::int32 req_trade::requestid() const {
  // @@protoc_insertion_point(field_get:risk.req_trade.requestid)
  return requestid_;
}
inline void req_trade::set_requestid(::google::protobuf::int32 value) {
  
  requestid_ = value;
  // @@protoc_insertion_point(field_set:risk.req_trade.requestid)
}

// repeated string investor = 2;
inline int req_trade::investor_size() const {
  return investor_.size();
}
inline void req_trade::clear_investor() {
  investor_.Clear();
}
inline const ::std::string& req_trade::investor(int index) const {
  // @@protoc_insertion_point(field_get:risk.req_trade.investor)
  return investor_.Get(index);
}
inline ::std::string* req_trade::mutable_investor(int index) {
  // @@protoc_insertion_point(field_mutable:risk.req_trade.investor)
  return investor_.Mutable(index);
}
inline void req_trade::set_investor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.req_trade.investor)
  investor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void req_trade::set_investor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.req_trade.investor)
  investor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void req_trade::set_investor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.req_trade.investor)
}
inline void req_trade::set_investor(int index, const char* value, size_t size) {
  investor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.req_trade.investor)
}
inline ::std::string* req_trade::add_investor() {
  // @@protoc_insertion_point(field_add_mutable:risk.req_trade.investor)
  return investor_.Add();
}
inline void req_trade::add_investor(const ::std::string& value) {
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.req_trade.investor)
}
#if LANG_CXX11
inline void req_trade::add_investor(::std::string&& value) {
  investor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.req_trade.investor)
}
#endif
inline void req_trade::add_investor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.req_trade.investor)
}
inline void req_trade::add_investor(const char* value, size_t size) {
  investor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.req_trade.investor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
req_trade::investor() const {
  // @@protoc_insertion_point(field_list:risk.req_trade.investor)
  return investor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
req_trade::mutable_investor() {
  // @@protoc_insertion_point(field_mutable_list:risk.req_trade.investor)
  return &investor_;
}

// -------------------------------------------------------------------

// req_order

// int32 requestid = 1;
inline void req_order::clear_requestid() {
  requestid_ = 0;
}
inline ::google::protobuf::int32 req_order::requestid() const {
  // @@protoc_insertion_point(field_get:risk.req_order.requestid)
  return requestid_;
}
inline void req_order::set_requestid(::google::protobuf::int32 value) {
  
  requestid_ = value;
  // @@protoc_insertion_point(field_set:risk.req_order.requestid)
}

// repeated string investor = 2;
inline int req_order::investor_size() const {
  return investor_.size();
}
inline void req_order::clear_investor() {
  investor_.Clear();
}
inline const ::std::string& req_order::investor(int index) const {
  // @@protoc_insertion_point(field_get:risk.req_order.investor)
  return investor_.Get(index);
}
inline ::std::string* req_order::mutable_investor(int index) {
  // @@protoc_insertion_point(field_mutable:risk.req_order.investor)
  return investor_.Mutable(index);
}
inline void req_order::set_investor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.req_order.investor)
  investor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void req_order::set_investor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.req_order.investor)
  investor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void req_order::set_investor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.req_order.investor)
}
inline void req_order::set_investor(int index, const char* value, size_t size) {
  investor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.req_order.investor)
}
inline ::std::string* req_order::add_investor() {
  // @@protoc_insertion_point(field_add_mutable:risk.req_order.investor)
  return investor_.Add();
}
inline void req_order::add_investor(const ::std::string& value) {
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.req_order.investor)
}
#if LANG_CXX11
inline void req_order::add_investor(::std::string&& value) {
  investor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.req_order.investor)
}
#endif
inline void req_order::add_investor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.req_order.investor)
}
inline void req_order::add_investor(const char* value, size_t size) {
  investor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.req_order.investor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
req_order::investor() const {
  // @@protoc_insertion_point(field_list:risk.req_order.investor)
  return investor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
req_order::mutable_investor() {
  // @@protoc_insertion_point(field_mutable_list:risk.req_order.investor)
  return &investor_;
}

// -------------------------------------------------------------------

// private_topic_info

// string investor = 1;
inline void private_topic_info::clear_investor() {
  investor_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& private_topic_info::investor() const {
  // @@protoc_insertion_point(field_get:risk.private_topic_info.investor)
  return investor_.GetNoArena();
}
inline void private_topic_info::set_investor(const ::std::string& value) {
  
  investor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.private_topic_info.investor)
}
#if LANG_CXX11
inline void private_topic_info::set_investor(::std::string&& value) {
  
  investor_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.private_topic_info.investor)
}
#endif
inline void private_topic_info::set_investor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  investor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.private_topic_info.investor)
}
inline void private_topic_info::set_investor(const char* value, size_t size) {
  
  investor_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.private_topic_info.investor)
}
inline ::std::string* private_topic_info::mutable_investor() {
  
  // @@protoc_insertion_point(field_mutable:risk.private_topic_info.investor)
  return investor_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* private_topic_info::release_investor() {
  // @@protoc_insertion_point(field_release:risk.private_topic_info.investor)
  
  return investor_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void private_topic_info::set_allocated_investor(::std::string* investor) {
  if (investor != NULL) {
    
  } else {
    
  }
  investor_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), investor);
  // @@protoc_insertion_point(field_set_allocated:risk.private_topic_info.investor)
}

// int32 id = 2;
inline void private_topic_info::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 private_topic_info::id() const {
  // @@protoc_insertion_point(field_get:risk.private_topic_info.id)
  return id_;
}
inline void private_topic_info::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:risk.private_topic_info.id)
}

// -------------------------------------------------------------------

// subscribe_private_topic

// repeated .risk.private_topic_info field = 1;
inline int subscribe_private_topic::field_size() const {
  return field_.size();
}
inline void subscribe_private_topic::clear_field() {
  field_.Clear();
}
inline const ::risk::private_topic_info& subscribe_private_topic::field(int index) const {
  // @@protoc_insertion_point(field_get:risk.subscribe_private_topic.field)
  return field_.Get(index);
}
inline ::risk::private_topic_info* subscribe_private_topic::mutable_field(int index) {
  // @@protoc_insertion_point(field_mutable:risk.subscribe_private_topic.field)
  return field_.Mutable(index);
}
inline ::risk::private_topic_info* subscribe_private_topic::add_field() {
  // @@protoc_insertion_point(field_add:risk.subscribe_private_topic.field)
  return field_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::risk::private_topic_info >*
subscribe_private_topic::mutable_field() {
  // @@protoc_insertion_point(field_mutable_list:risk.subscribe_private_topic.field)
  return &field_;
}
inline const ::google::protobuf::RepeatedPtrField< ::risk::private_topic_info >&
subscribe_private_topic::field() const {
  // @@protoc_insertion_point(field_list:risk.subscribe_private_topic.field)
  return field_;
}

// -------------------------------------------------------------------

// unsubscribe_private_topic

// repeated string investor = 1;
inline int unsubscribe_private_topic::investor_size() const {
  return investor_.size();
}
inline void unsubscribe_private_topic::clear_investor() {
  investor_.Clear();
}
inline const ::std::string& unsubscribe_private_topic::investor(int index) const {
  // @@protoc_insertion_point(field_get:risk.unsubscribe_private_topic.investor)
  return investor_.Get(index);
}
inline ::std::string* unsubscribe_private_topic::mutable_investor(int index) {
  // @@protoc_insertion_point(field_mutable:risk.unsubscribe_private_topic.investor)
  return investor_.Mutable(index);
}
inline void unsubscribe_private_topic::set_investor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.unsubscribe_private_topic.investor)
  investor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void unsubscribe_private_topic::set_investor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.unsubscribe_private_topic.investor)
  investor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void unsubscribe_private_topic::set_investor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.unsubscribe_private_topic.investor)
}
inline void unsubscribe_private_topic::set_investor(int index, const char* value, size_t size) {
  investor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.unsubscribe_private_topic.investor)
}
inline ::std::string* unsubscribe_private_topic::add_investor() {
  // @@protoc_insertion_point(field_add_mutable:risk.unsubscribe_private_topic.investor)
  return investor_.Add();
}
inline void unsubscribe_private_topic::add_investor(const ::std::string& value) {
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.unsubscribe_private_topic.investor)
}
#if LANG_CXX11
inline void unsubscribe_private_topic::add_investor(::std::string&& value) {
  investor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.unsubscribe_private_topic.investor)
}
#endif
inline void unsubscribe_private_topic::add_investor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.unsubscribe_private_topic.investor)
}
inline void unsubscribe_private_topic::add_investor(const char* value, size_t size) {
  investor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.unsubscribe_private_topic.investor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
unsubscribe_private_topic::investor() const {
  // @@protoc_insertion_point(field_list:risk.unsubscribe_private_topic.investor)
  return investor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
unsubscribe_private_topic::mutable_investor() {
  // @@protoc_insertion_point(field_mutable_list:risk.unsubscribe_private_topic.investor)
  return &investor_;
}

// -------------------------------------------------------------------

// req_sync_account

// int32 requestid = 1;
inline void req_sync_account::clear_requestid() {
  requestid_ = 0;
}
inline ::google::protobuf::int32 req_sync_account::requestid() const {
  // @@protoc_insertion_point(field_get:risk.req_sync_account.requestid)
  return requestid_;
}
inline void req_sync_account::set_requestid(::google::protobuf::int32 value) {
  
  requestid_ = value;
  // @@protoc_insertion_point(field_set:risk.req_sync_account.requestid)
}

// repeated string investor = 2;
inline int req_sync_account::investor_size() const {
  return investor_.size();
}
inline void req_sync_account::clear_investor() {
  investor_.Clear();
}
inline const ::std::string& req_sync_account::investor(int index) const {
  // @@protoc_insertion_point(field_get:risk.req_sync_account.investor)
  return investor_.Get(index);
}
inline ::std::string* req_sync_account::mutable_investor(int index) {
  // @@protoc_insertion_point(field_mutable:risk.req_sync_account.investor)
  return investor_.Mutable(index);
}
inline void req_sync_account::set_investor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.req_sync_account.investor)
  investor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void req_sync_account::set_investor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.req_sync_account.investor)
  investor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void req_sync_account::set_investor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.req_sync_account.investor)
}
inline void req_sync_account::set_investor(int index, const char* value, size_t size) {
  investor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.req_sync_account.investor)
}
inline ::std::string* req_sync_account::add_investor() {
  // @@protoc_insertion_point(field_add_mutable:risk.req_sync_account.investor)
  return investor_.Add();
}
inline void req_sync_account::add_investor(const ::std::string& value) {
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.req_sync_account.investor)
}
#if LANG_CXX11
inline void req_sync_account::add_investor(::std::string&& value) {
  investor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.req_sync_account.investor)
}
#endif
inline void req_sync_account::add_investor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.req_sync_account.investor)
}
inline void req_sync_account::add_investor(const char* value, size_t size) {
  investor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.req_sync_account.investor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
req_sync_account::investor() const {
  // @@protoc_insertion_point(field_list:risk.req_sync_account.investor)
  return investor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
req_sync_account::mutable_investor() {
  // @@protoc_insertion_point(field_mutable_list:risk.req_sync_account.investor)
  return &investor_;
}

// -------------------------------------------------------------------

// subscribe_sync_account

// repeated string investor = 1;
inline int subscribe_sync_account::investor_size() const {
  return investor_.size();
}
inline void subscribe_sync_account::clear_investor() {
  investor_.Clear();
}
inline const ::std::string& subscribe_sync_account::investor(int index) const {
  // @@protoc_insertion_point(field_get:risk.subscribe_sync_account.investor)
  return investor_.Get(index);
}
inline ::std::string* subscribe_sync_account::mutable_investor(int index) {
  // @@protoc_insertion_point(field_mutable:risk.subscribe_sync_account.investor)
  return investor_.Mutable(index);
}
inline void subscribe_sync_account::set_investor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.subscribe_sync_account.investor)
  investor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void subscribe_sync_account::set_investor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.subscribe_sync_account.investor)
  investor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void subscribe_sync_account::set_investor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.subscribe_sync_account.investor)
}
inline void subscribe_sync_account::set_investor(int index, const char* value, size_t size) {
  investor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.subscribe_sync_account.investor)
}
inline ::std::string* subscribe_sync_account::add_investor() {
  // @@protoc_insertion_point(field_add_mutable:risk.subscribe_sync_account.investor)
  return investor_.Add();
}
inline void subscribe_sync_account::add_investor(const ::std::string& value) {
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.subscribe_sync_account.investor)
}
#if LANG_CXX11
inline void subscribe_sync_account::add_investor(::std::string&& value) {
  investor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.subscribe_sync_account.investor)
}
#endif
inline void subscribe_sync_account::add_investor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.subscribe_sync_account.investor)
}
inline void subscribe_sync_account::add_investor(const char* value, size_t size) {
  investor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.subscribe_sync_account.investor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
subscribe_sync_account::investor() const {
  // @@protoc_insertion_point(field_list:risk.subscribe_sync_account.investor)
  return investor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
subscribe_sync_account::mutable_investor() {
  // @@protoc_insertion_point(field_mutable_list:risk.subscribe_sync_account.investor)
  return &investor_;
}

// -------------------------------------------------------------------

// unsubscribe_sync_account

// repeated string investor = 1;
inline int unsubscribe_sync_account::investor_size() const {
  return investor_.size();
}
inline void unsubscribe_sync_account::clear_investor() {
  investor_.Clear();
}
inline const ::std::string& unsubscribe_sync_account::investor(int index) const {
  // @@protoc_insertion_point(field_get:risk.unsubscribe_sync_account.investor)
  return investor_.Get(index);
}
inline ::std::string* unsubscribe_sync_account::mutable_investor(int index) {
  // @@protoc_insertion_point(field_mutable:risk.unsubscribe_sync_account.investor)
  return investor_.Mutable(index);
}
inline void unsubscribe_sync_account::set_investor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.unsubscribe_sync_account.investor)
  investor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void unsubscribe_sync_account::set_investor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.unsubscribe_sync_account.investor)
  investor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void unsubscribe_sync_account::set_investor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.unsubscribe_sync_account.investor)
}
inline void unsubscribe_sync_account::set_investor(int index, const char* value, size_t size) {
  investor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.unsubscribe_sync_account.investor)
}
inline ::std::string* unsubscribe_sync_account::add_investor() {
  // @@protoc_insertion_point(field_add_mutable:risk.unsubscribe_sync_account.investor)
  return investor_.Add();
}
inline void unsubscribe_sync_account::add_investor(const ::std::string& value) {
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.unsubscribe_sync_account.investor)
}
#if LANG_CXX11
inline void unsubscribe_sync_account::add_investor(::std::string&& value) {
  investor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.unsubscribe_sync_account.investor)
}
#endif
inline void unsubscribe_sync_account::add_investor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.unsubscribe_sync_account.investor)
}
inline void unsubscribe_sync_account::add_investor(const char* value, size_t size) {
  investor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.unsubscribe_sync_account.investor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
unsubscribe_sync_account::investor() const {
  // @@protoc_insertion_point(field_list:risk.unsubscribe_sync_account.investor)
  return investor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
unsubscribe_sync_account::mutable_investor() {
  // @@protoc_insertion_point(field_mutable_list:risk.unsubscribe_sync_account.investor)
  return &investor_;
}

// -------------------------------------------------------------------

// req_margin

// int32 requestid = 1;
inline void req_margin::clear_requestid() {
  requestid_ = 0;
}
inline ::google::protobuf::int32 req_margin::requestid() const {
  // @@protoc_insertion_point(field_get:risk.req_margin.requestid)
  return requestid_;
}
inline void req_margin::set_requestid(::google::protobuf::int32 value) {
  
  requestid_ = value;
  // @@protoc_insertion_point(field_set:risk.req_margin.requestid)
}

// repeated string investor = 2;
inline int req_margin::investor_size() const {
  return investor_.size();
}
inline void req_margin::clear_investor() {
  investor_.Clear();
}
inline const ::std::string& req_margin::investor(int index) const {
  // @@protoc_insertion_point(field_get:risk.req_margin.investor)
  return investor_.Get(index);
}
inline ::std::string* req_margin::mutable_investor(int index) {
  // @@protoc_insertion_point(field_mutable:risk.req_margin.investor)
  return investor_.Mutable(index);
}
inline void req_margin::set_investor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.req_margin.investor)
  investor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void req_margin::set_investor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.req_margin.investor)
  investor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void req_margin::set_investor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.req_margin.investor)
}
inline void req_margin::set_investor(int index, const char* value, size_t size) {
  investor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.req_margin.investor)
}
inline ::std::string* req_margin::add_investor() {
  // @@protoc_insertion_point(field_add_mutable:risk.req_margin.investor)
  return investor_.Add();
}
inline void req_margin::add_investor(const ::std::string& value) {
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.req_margin.investor)
}
#if LANG_CXX11
inline void req_margin::add_investor(::std::string&& value) {
  investor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.req_margin.investor)
}
#endif
inline void req_margin::add_investor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.req_margin.investor)
}
inline void req_margin::add_investor(const char* value, size_t size) {
  investor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.req_margin.investor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
req_margin::investor() const {
  // @@protoc_insertion_point(field_list:risk.req_margin.investor)
  return investor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
req_margin::mutable_investor() {
  // @@protoc_insertion_point(field_mutable_list:risk.req_margin.investor)
  return &investor_;
}

// -------------------------------------------------------------------

// subscribe_margin

// repeated string investor = 1;
inline int subscribe_margin::investor_size() const {
  return investor_.size();
}
inline void subscribe_margin::clear_investor() {
  investor_.Clear();
}
inline const ::std::string& subscribe_margin::investor(int index) const {
  // @@protoc_insertion_point(field_get:risk.subscribe_margin.investor)
  return investor_.Get(index);
}
inline ::std::string* subscribe_margin::mutable_investor(int index) {
  // @@protoc_insertion_point(field_mutable:risk.subscribe_margin.investor)
  return investor_.Mutable(index);
}
inline void subscribe_margin::set_investor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.subscribe_margin.investor)
  investor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void subscribe_margin::set_investor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.subscribe_margin.investor)
  investor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void subscribe_margin::set_investor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.subscribe_margin.investor)
}
inline void subscribe_margin::set_investor(int index, const char* value, size_t size) {
  investor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.subscribe_margin.investor)
}
inline ::std::string* subscribe_margin::add_investor() {
  // @@protoc_insertion_point(field_add_mutable:risk.subscribe_margin.investor)
  return investor_.Add();
}
inline void subscribe_margin::add_investor(const ::std::string& value) {
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.subscribe_margin.investor)
}
#if LANG_CXX11
inline void subscribe_margin::add_investor(::std::string&& value) {
  investor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.subscribe_margin.investor)
}
#endif
inline void subscribe_margin::add_investor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.subscribe_margin.investor)
}
inline void subscribe_margin::add_investor(const char* value, size_t size) {
  investor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.subscribe_margin.investor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
subscribe_margin::investor() const {
  // @@protoc_insertion_point(field_list:risk.subscribe_margin.investor)
  return investor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
subscribe_margin::mutable_investor() {
  // @@protoc_insertion_point(field_mutable_list:risk.subscribe_margin.investor)
  return &investor_;
}

// -------------------------------------------------------------------

// unsubscribe_margin

// repeated string investor = 1;
inline int unsubscribe_margin::investor_size() const {
  return investor_.size();
}
inline void unsubscribe_margin::clear_investor() {
  investor_.Clear();
}
inline const ::std::string& unsubscribe_margin::investor(int index) const {
  // @@protoc_insertion_point(field_get:risk.unsubscribe_margin.investor)
  return investor_.Get(index);
}
inline ::std::string* unsubscribe_margin::mutable_investor(int index) {
  // @@protoc_insertion_point(field_mutable:risk.unsubscribe_margin.investor)
  return investor_.Mutable(index);
}
inline void unsubscribe_margin::set_investor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.unsubscribe_margin.investor)
  investor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void unsubscribe_margin::set_investor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.unsubscribe_margin.investor)
  investor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void unsubscribe_margin::set_investor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.unsubscribe_margin.investor)
}
inline void unsubscribe_margin::set_investor(int index, const char* value, size_t size) {
  investor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.unsubscribe_margin.investor)
}
inline ::std::string* unsubscribe_margin::add_investor() {
  // @@protoc_insertion_point(field_add_mutable:risk.unsubscribe_margin.investor)
  return investor_.Add();
}
inline void unsubscribe_margin::add_investor(const ::std::string& value) {
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.unsubscribe_margin.investor)
}
#if LANG_CXX11
inline void unsubscribe_margin::add_investor(::std::string&& value) {
  investor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.unsubscribe_margin.investor)
}
#endif
inline void unsubscribe_margin::add_investor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.unsubscribe_margin.investor)
}
inline void unsubscribe_margin::add_investor(const char* value, size_t size) {
  investor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.unsubscribe_margin.investor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
unsubscribe_margin::investor() const {
  // @@protoc_insertion_point(field_list:risk.unsubscribe_margin.investor)
  return investor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
unsubscribe_margin::mutable_investor() {
  // @@protoc_insertion_point(field_mutable_list:risk.unsubscribe_margin.investor)
  return &investor_;
}

// -------------------------------------------------------------------

// req_risker_investor

// int32 requestid = 1;
inline void req_risker_investor::clear_requestid() {
  requestid_ = 0;
}
inline ::google::protobuf::int32 req_risker_investor::requestid() const {
  // @@protoc_insertion_point(field_get:risk.req_risker_investor.requestid)
  return requestid_;
}
inline void req_risker_investor::set_requestid(::google::protobuf::int32 value) {
  
  requestid_ = value;
  // @@protoc_insertion_point(field_set:risk.req_risker_investor.requestid)
}

// string userid = 2;
inline void req_risker_investor::clear_userid() {
  userid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& req_risker_investor::userid() const {
  // @@protoc_insertion_point(field_get:risk.req_risker_investor.userid)
  return userid_.GetNoArena();
}
inline void req_risker_investor::set_userid(const ::std::string& value) {
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.req_risker_investor.userid)
}
#if LANG_CXX11
inline void req_risker_investor::set_userid(::std::string&& value) {
  
  userid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.req_risker_investor.userid)
}
#endif
inline void req_risker_investor::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.req_risker_investor.userid)
}
inline void req_risker_investor::set_userid(const char* value, size_t size) {
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.req_risker_investor.userid)
}
inline ::std::string* req_risker_investor::mutable_userid() {
  
  // @@protoc_insertion_point(field_mutable:risk.req_risker_investor.userid)
  return userid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* req_risker_investor::release_userid() {
  // @@protoc_insertion_point(field_release:risk.req_risker_investor.userid)
  
  return userid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void req_risker_investor::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    
  } else {
    
  }
  userid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:risk.req_risker_investor.userid)
}

// -------------------------------------------------------------------

// sys_group

// string riskgroupid = 1;
inline void sys_group::clear_riskgroupid() {
  riskgroupid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& sys_group::riskgroupid() const {
  // @@protoc_insertion_point(field_get:risk.sys_group.riskgroupid)
  return riskgroupid_.GetNoArena();
}
inline void sys_group::set_riskgroupid(const ::std::string& value) {
  
  riskgroupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.sys_group.riskgroupid)
}
#if LANG_CXX11
inline void sys_group::set_riskgroupid(::std::string&& value) {
  
  riskgroupid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.sys_group.riskgroupid)
}
#endif
inline void sys_group::set_riskgroupid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  riskgroupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.sys_group.riskgroupid)
}
inline void sys_group::set_riskgroupid(const char* value, size_t size) {
  
  riskgroupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.sys_group.riskgroupid)
}
inline ::std::string* sys_group::mutable_riskgroupid() {
  
  // @@protoc_insertion_point(field_mutable:risk.sys_group.riskgroupid)
  return riskgroupid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* sys_group::release_riskgroupid() {
  // @@protoc_insertion_point(field_release:risk.sys_group.riskgroupid)
  
  return riskgroupid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void sys_group::set_allocated_riskgroupid(::std::string* riskgroupid) {
  if (riskgroupid != NULL) {
    
  } else {
    
  }
  riskgroupid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), riskgroupid);
  // @@protoc_insertion_point(field_set_allocated:risk.sys_group.riskgroupid)
}

// string name = 2;
inline void sys_group::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& sys_group::name() const {
  // @@protoc_insertion_point(field_get:risk.sys_group.name)
  return name_.GetNoArena();
}
inline void sys_group::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.sys_group.name)
}
#if LANG_CXX11
inline void sys_group::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.sys_group.name)
}
#endif
inline void sys_group::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.sys_group.name)
}
inline void sys_group::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.sys_group.name)
}
inline ::std::string* sys_group::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:risk.sys_group.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* sys_group::release_name() {
  // @@protoc_insertion_point(field_release:risk.sys_group.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void sys_group::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:risk.sys_group.name)
}

// string desc = 3;
inline void sys_group::clear_desc() {
  desc_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& sys_group::desc() const {
  // @@protoc_insertion_point(field_get:risk.sys_group.desc)
  return desc_.GetNoArena();
}
inline void sys_group::set_desc(const ::std::string& value) {
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.sys_group.desc)
}
#if LANG_CXX11
inline void sys_group::set_desc(::std::string&& value) {
  
  desc_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.sys_group.desc)
}
#endif
inline void sys_group::set_desc(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.sys_group.desc)
}
inline void sys_group::set_desc(const char* value, size_t size) {
  
  desc_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.sys_group.desc)
}
inline ::std::string* sys_group::mutable_desc() {
  
  // @@protoc_insertion_point(field_mutable:risk.sys_group.desc)
  return desc_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* sys_group::release_desc() {
  // @@protoc_insertion_point(field_release:risk.sys_group.desc)
  
  return desc_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void sys_group::set_allocated_desc(::std::string* desc) {
  if (desc != NULL) {
    
  } else {
    
  }
  desc_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), desc);
  // @@protoc_insertion_point(field_set_allocated:risk.sys_group.desc)
}

// -------------------------------------------------------------------

// req_groups

// int32 requestid = 1;
inline void req_groups::clear_requestid() {
  requestid_ = 0;
}
inline ::google::protobuf::int32 req_groups::requestid() const {
  // @@protoc_insertion_point(field_get:risk.req_groups.requestid)
  return requestid_;
}
inline void req_groups::set_requestid(::google::protobuf::int32 value) {
  
  requestid_ = value;
  // @@protoc_insertion_point(field_set:risk.req_groups.requestid)
}

// string userid = 2;
inline void req_groups::clear_userid() {
  userid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& req_groups::userid() const {
  // @@protoc_insertion_point(field_get:risk.req_groups.userid)
  return userid_.GetNoArena();
}
inline void req_groups::set_userid(const ::std::string& value) {
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.req_groups.userid)
}
#if LANG_CXX11
inline void req_groups::set_userid(::std::string&& value) {
  
  userid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.req_groups.userid)
}
#endif
inline void req_groups::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.req_groups.userid)
}
inline void req_groups::set_userid(const char* value, size_t size) {
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.req_groups.userid)
}
inline ::std::string* req_groups::mutable_userid() {
  
  // @@protoc_insertion_point(field_mutable:risk.req_groups.userid)
  return userid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* req_groups::release_userid() {
  // @@protoc_insertion_point(field_release:risk.req_groups.userid)
  
  return userid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void req_groups::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    
  } else {
    
  }
  userid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:risk.req_groups.userid)
}

// -------------------------------------------------------------------

// req_add_group

// int32 requestid = 1;
inline void req_add_group::clear_requestid() {
  requestid_ = 0;
}
inline ::google::protobuf::int32 req_add_group::requestid() const {
  // @@protoc_insertion_point(field_get:risk.req_add_group.requestid)
  return requestid_;
}
inline void req_add_group::set_requestid(::google::protobuf::int32 value) {
  
  requestid_ = value;
  // @@protoc_insertion_point(field_set:risk.req_add_group.requestid)
}

// string userid = 2;
inline void req_add_group::clear_userid() {
  userid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& req_add_group::userid() const {
  // @@protoc_insertion_point(field_get:risk.req_add_group.userid)
  return userid_.GetNoArena();
}
inline void req_add_group::set_userid(const ::std::string& value) {
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.req_add_group.userid)
}
#if LANG_CXX11
inline void req_add_group::set_userid(::std::string&& value) {
  
  userid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.req_add_group.userid)
}
#endif
inline void req_add_group::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.req_add_group.userid)
}
inline void req_add_group::set_userid(const char* value, size_t size) {
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.req_add_group.userid)
}
inline ::std::string* req_add_group::mutable_userid() {
  
  // @@protoc_insertion_point(field_mutable:risk.req_add_group.userid)
  return userid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* req_add_group::release_userid() {
  // @@protoc_insertion_point(field_release:risk.req_add_group.userid)
  
  return userid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void req_add_group::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    
  } else {
    
  }
  userid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:risk.req_add_group.userid)
}

// .risk.sys_group group = 3;
inline bool req_add_group::has_group() const {
  return this != internal_default_instance() && group_ != NULL;
}
inline void req_add_group::clear_group() {
  if (GetArenaNoVirtual() == NULL && group_ != NULL) delete group_;
  group_ = NULL;
}
inline const ::risk::sys_group& req_add_group::group() const {
  const ::risk::sys_group* p = group_;
  // @@protoc_insertion_point(field_get:risk.req_add_group.group)
  return p != NULL ? *p : *reinterpret_cast<const ::risk::sys_group*>(
      &::risk::_sys_group_default_instance_);
}
inline ::risk::sys_group* req_add_group::mutable_group() {
  
  if (group_ == NULL) {
    group_ = new ::risk::sys_group;
  }
  // @@protoc_insertion_point(field_mutable:risk.req_add_group.group)
  return group_;
}
inline ::risk::sys_group* req_add_group::release_group() {
  // @@protoc_insertion_point(field_release:risk.req_add_group.group)
  
  ::risk::sys_group* temp = group_;
  group_ = NULL;
  return temp;
}
inline void req_add_group::set_allocated_group(::risk::sys_group* group) {
  delete group_;
  group_ = group;
  if (group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:risk.req_add_group.group)
}

// -------------------------------------------------------------------

// req_del_group

// int32 requestid = 1;
inline void req_del_group::clear_requestid() {
  requestid_ = 0;
}
inline ::google::protobuf::int32 req_del_group::requestid() const {
  // @@protoc_insertion_point(field_get:risk.req_del_group.requestid)
  return requestid_;
}
inline void req_del_group::set_requestid(::google::protobuf::int32 value) {
  
  requestid_ = value;
  // @@protoc_insertion_point(field_set:risk.req_del_group.requestid)
}

// string userid = 2;
inline void req_del_group::clear_userid() {
  userid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& req_del_group::userid() const {
  // @@protoc_insertion_point(field_get:risk.req_del_group.userid)
  return userid_.GetNoArena();
}
inline void req_del_group::set_userid(const ::std::string& value) {
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.req_del_group.userid)
}
#if LANG_CXX11
inline void req_del_group::set_userid(::std::string&& value) {
  
  userid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.req_del_group.userid)
}
#endif
inline void req_del_group::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.req_del_group.userid)
}
inline void req_del_group::set_userid(const char* value, size_t size) {
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.req_del_group.userid)
}
inline ::std::string* req_del_group::mutable_userid() {
  
  // @@protoc_insertion_point(field_mutable:risk.req_del_group.userid)
  return userid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* req_del_group::release_userid() {
  // @@protoc_insertion_point(field_release:risk.req_del_group.userid)
  
  return userid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void req_del_group::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    
  } else {
    
  }
  userid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:risk.req_del_group.userid)
}

// string riskgroupid = 3;
inline void req_del_group::clear_riskgroupid() {
  riskgroupid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& req_del_group::riskgroupid() const {
  // @@protoc_insertion_point(field_get:risk.req_del_group.riskgroupid)
  return riskgroupid_.GetNoArena();
}
inline void req_del_group::set_riskgroupid(const ::std::string& value) {
  
  riskgroupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.req_del_group.riskgroupid)
}
#if LANG_CXX11
inline void req_del_group::set_riskgroupid(::std::string&& value) {
  
  riskgroupid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.req_del_group.riskgroupid)
}
#endif
inline void req_del_group::set_riskgroupid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  riskgroupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.req_del_group.riskgroupid)
}
inline void req_del_group::set_riskgroupid(const char* value, size_t size) {
  
  riskgroupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.req_del_group.riskgroupid)
}
inline ::std::string* req_del_group::mutable_riskgroupid() {
  
  // @@protoc_insertion_point(field_mutable:risk.req_del_group.riskgroupid)
  return riskgroupid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* req_del_group::release_riskgroupid() {
  // @@protoc_insertion_point(field_release:risk.req_del_group.riskgroupid)
  
  return riskgroupid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void req_del_group::set_allocated_riskgroupid(::std::string* riskgroupid) {
  if (riskgroupid != NULL) {
    
  } else {
    
  }
  riskgroupid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), riskgroupid);
  // @@protoc_insertion_point(field_set_allocated:risk.req_del_group.riskgroupid)
}

// -------------------------------------------------------------------

// req_edit_group

// int32 requestid = 1;
inline void req_edit_group::clear_requestid() {
  requestid_ = 0;
}
inline ::google::protobuf::int32 req_edit_group::requestid() const {
  // @@protoc_insertion_point(field_get:risk.req_edit_group.requestid)
  return requestid_;
}
inline void req_edit_group::set_requestid(::google::protobuf::int32 value) {
  
  requestid_ = value;
  // @@protoc_insertion_point(field_set:risk.req_edit_group.requestid)
}

// string userid = 2;
inline void req_edit_group::clear_userid() {
  userid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& req_edit_group::userid() const {
  // @@protoc_insertion_point(field_get:risk.req_edit_group.userid)
  return userid_.GetNoArena();
}
inline void req_edit_group::set_userid(const ::std::string& value) {
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.req_edit_group.userid)
}
#if LANG_CXX11
inline void req_edit_group::set_userid(::std::string&& value) {
  
  userid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.req_edit_group.userid)
}
#endif
inline void req_edit_group::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.req_edit_group.userid)
}
inline void req_edit_group::set_userid(const char* value, size_t size) {
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.req_edit_group.userid)
}
inline ::std::string* req_edit_group::mutable_userid() {
  
  // @@protoc_insertion_point(field_mutable:risk.req_edit_group.userid)
  return userid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* req_edit_group::release_userid() {
  // @@protoc_insertion_point(field_release:risk.req_edit_group.userid)
  
  return userid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void req_edit_group::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    
  } else {
    
  }
  userid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:risk.req_edit_group.userid)
}

// .risk.sys_group group = 3;
inline bool req_edit_group::has_group() const {
  return this != internal_default_instance() && group_ != NULL;
}
inline void req_edit_group::clear_group() {
  if (GetArenaNoVirtual() == NULL && group_ != NULL) delete group_;
  group_ = NULL;
}
inline const ::risk::sys_group& req_edit_group::group() const {
  const ::risk::sys_group* p = group_;
  // @@protoc_insertion_point(field_get:risk.req_edit_group.group)
  return p != NULL ? *p : *reinterpret_cast<const ::risk::sys_group*>(
      &::risk::_sys_group_default_instance_);
}
inline ::risk::sys_group* req_edit_group::mutable_group() {
  
  if (group_ == NULL) {
    group_ = new ::risk::sys_group;
  }
  // @@protoc_insertion_point(field_mutable:risk.req_edit_group.group)
  return group_;
}
inline ::risk::sys_group* req_edit_group::release_group() {
  // @@protoc_insertion_point(field_release:risk.req_edit_group.group)
  
  ::risk::sys_group* temp = group_;
  group_ = NULL;
  return temp;
}
inline void req_edit_group::set_allocated_group(::risk::sys_group* group) {
  delete group_;
  group_ = group;
  if (group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:risk.req_edit_group.group)
}

// -------------------------------------------------------------------

// req_insert_investors_to_group

// int32 requestid = 1;
inline void req_insert_investors_to_group::clear_requestid() {
  requestid_ = 0;
}
inline ::google::protobuf::int32 req_insert_investors_to_group::requestid() const {
  // @@protoc_insertion_point(field_get:risk.req_insert_investors_to_group.requestid)
  return requestid_;
}
inline void req_insert_investors_to_group::set_requestid(::google::protobuf::int32 value) {
  
  requestid_ = value;
  // @@protoc_insertion_point(field_set:risk.req_insert_investors_to_group.requestid)
}

// string userid = 2;
inline void req_insert_investors_to_group::clear_userid() {
  userid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& req_insert_investors_to_group::userid() const {
  // @@protoc_insertion_point(field_get:risk.req_insert_investors_to_group.userid)
  return userid_.GetNoArena();
}
inline void req_insert_investors_to_group::set_userid(const ::std::string& value) {
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.req_insert_investors_to_group.userid)
}
#if LANG_CXX11
inline void req_insert_investors_to_group::set_userid(::std::string&& value) {
  
  userid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.req_insert_investors_to_group.userid)
}
#endif
inline void req_insert_investors_to_group::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.req_insert_investors_to_group.userid)
}
inline void req_insert_investors_to_group::set_userid(const char* value, size_t size) {
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.req_insert_investors_to_group.userid)
}
inline ::std::string* req_insert_investors_to_group::mutable_userid() {
  
  // @@protoc_insertion_point(field_mutable:risk.req_insert_investors_to_group.userid)
  return userid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* req_insert_investors_to_group::release_userid() {
  // @@protoc_insertion_point(field_release:risk.req_insert_investors_to_group.userid)
  
  return userid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void req_insert_investors_to_group::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    
  } else {
    
  }
  userid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:risk.req_insert_investors_to_group.userid)
}

// string riskgroupid = 3;
inline void req_insert_investors_to_group::clear_riskgroupid() {
  riskgroupid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& req_insert_investors_to_group::riskgroupid() const {
  // @@protoc_insertion_point(field_get:risk.req_insert_investors_to_group.riskgroupid)
  return riskgroupid_.GetNoArena();
}
inline void req_insert_investors_to_group::set_riskgroupid(const ::std::string& value) {
  
  riskgroupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.req_insert_investors_to_group.riskgroupid)
}
#if LANG_CXX11
inline void req_insert_investors_to_group::set_riskgroupid(::std::string&& value) {
  
  riskgroupid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.req_insert_investors_to_group.riskgroupid)
}
#endif
inline void req_insert_investors_to_group::set_riskgroupid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  riskgroupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.req_insert_investors_to_group.riskgroupid)
}
inline void req_insert_investors_to_group::set_riskgroupid(const char* value, size_t size) {
  
  riskgroupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.req_insert_investors_to_group.riskgroupid)
}
inline ::std::string* req_insert_investors_to_group::mutable_riskgroupid() {
  
  // @@protoc_insertion_point(field_mutable:risk.req_insert_investors_to_group.riskgroupid)
  return riskgroupid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* req_insert_investors_to_group::release_riskgroupid() {
  // @@protoc_insertion_point(field_release:risk.req_insert_investors_to_group.riskgroupid)
  
  return riskgroupid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void req_insert_investors_to_group::set_allocated_riskgroupid(::std::string* riskgroupid) {
  if (riskgroupid != NULL) {
    
  } else {
    
  }
  riskgroupid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), riskgroupid);
  // @@protoc_insertion_point(field_set_allocated:risk.req_insert_investors_to_group.riskgroupid)
}

// repeated string investor = 4;
inline int req_insert_investors_to_group::investor_size() const {
  return investor_.size();
}
inline void req_insert_investors_to_group::clear_investor() {
  investor_.Clear();
}
inline const ::std::string& req_insert_investors_to_group::investor(int index) const {
  // @@protoc_insertion_point(field_get:risk.req_insert_investors_to_group.investor)
  return investor_.Get(index);
}
inline ::std::string* req_insert_investors_to_group::mutable_investor(int index) {
  // @@protoc_insertion_point(field_mutable:risk.req_insert_investors_to_group.investor)
  return investor_.Mutable(index);
}
inline void req_insert_investors_to_group::set_investor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.req_insert_investors_to_group.investor)
  investor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void req_insert_investors_to_group::set_investor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.req_insert_investors_to_group.investor)
  investor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void req_insert_investors_to_group::set_investor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.req_insert_investors_to_group.investor)
}
inline void req_insert_investors_to_group::set_investor(int index, const char* value, size_t size) {
  investor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.req_insert_investors_to_group.investor)
}
inline ::std::string* req_insert_investors_to_group::add_investor() {
  // @@protoc_insertion_point(field_add_mutable:risk.req_insert_investors_to_group.investor)
  return investor_.Add();
}
inline void req_insert_investors_to_group::add_investor(const ::std::string& value) {
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.req_insert_investors_to_group.investor)
}
#if LANG_CXX11
inline void req_insert_investors_to_group::add_investor(::std::string&& value) {
  investor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.req_insert_investors_to_group.investor)
}
#endif
inline void req_insert_investors_to_group::add_investor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.req_insert_investors_to_group.investor)
}
inline void req_insert_investors_to_group::add_investor(const char* value, size_t size) {
  investor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.req_insert_investors_to_group.investor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
req_insert_investors_to_group::investor() const {
  // @@protoc_insertion_point(field_list:risk.req_insert_investors_to_group.investor)
  return investor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
req_insert_investors_to_group::mutable_investor() {
  // @@protoc_insertion_point(field_mutable_list:risk.req_insert_investors_to_group.investor)
  return &investor_;
}

// -------------------------------------------------------------------

// req_remove_investors_from_group

// int32 requestid = 1;
inline void req_remove_investors_from_group::clear_requestid() {
  requestid_ = 0;
}
inline ::google::protobuf::int32 req_remove_investors_from_group::requestid() const {
  // @@protoc_insertion_point(field_get:risk.req_remove_investors_from_group.requestid)
  return requestid_;
}
inline void req_remove_investors_from_group::set_requestid(::google::protobuf::int32 value) {
  
  requestid_ = value;
  // @@protoc_insertion_point(field_set:risk.req_remove_investors_from_group.requestid)
}

// string userid = 2;
inline void req_remove_investors_from_group::clear_userid() {
  userid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& req_remove_investors_from_group::userid() const {
  // @@protoc_insertion_point(field_get:risk.req_remove_investors_from_group.userid)
  return userid_.GetNoArena();
}
inline void req_remove_investors_from_group::set_userid(const ::std::string& value) {
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.req_remove_investors_from_group.userid)
}
#if LANG_CXX11
inline void req_remove_investors_from_group::set_userid(::std::string&& value) {
  
  userid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.req_remove_investors_from_group.userid)
}
#endif
inline void req_remove_investors_from_group::set_userid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.req_remove_investors_from_group.userid)
}
inline void req_remove_investors_from_group::set_userid(const char* value, size_t size) {
  
  userid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.req_remove_investors_from_group.userid)
}
inline ::std::string* req_remove_investors_from_group::mutable_userid() {
  
  // @@protoc_insertion_point(field_mutable:risk.req_remove_investors_from_group.userid)
  return userid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* req_remove_investors_from_group::release_userid() {
  // @@protoc_insertion_point(field_release:risk.req_remove_investors_from_group.userid)
  
  return userid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void req_remove_investors_from_group::set_allocated_userid(::std::string* userid) {
  if (userid != NULL) {
    
  } else {
    
  }
  userid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), userid);
  // @@protoc_insertion_point(field_set_allocated:risk.req_remove_investors_from_group.userid)
}

// string riskgroupid = 3;
inline void req_remove_investors_from_group::clear_riskgroupid() {
  riskgroupid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& req_remove_investors_from_group::riskgroupid() const {
  // @@protoc_insertion_point(field_get:risk.req_remove_investors_from_group.riskgroupid)
  return riskgroupid_.GetNoArena();
}
inline void req_remove_investors_from_group::set_riskgroupid(const ::std::string& value) {
  
  riskgroupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.req_remove_investors_from_group.riskgroupid)
}
#if LANG_CXX11
inline void req_remove_investors_from_group::set_riskgroupid(::std::string&& value) {
  
  riskgroupid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.req_remove_investors_from_group.riskgroupid)
}
#endif
inline void req_remove_investors_from_group::set_riskgroupid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  riskgroupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.req_remove_investors_from_group.riskgroupid)
}
inline void req_remove_investors_from_group::set_riskgroupid(const char* value, size_t size) {
  
  riskgroupid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.req_remove_investors_from_group.riskgroupid)
}
inline ::std::string* req_remove_investors_from_group::mutable_riskgroupid() {
  
  // @@protoc_insertion_point(field_mutable:risk.req_remove_investors_from_group.riskgroupid)
  return riskgroupid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* req_remove_investors_from_group::release_riskgroupid() {
  // @@protoc_insertion_point(field_release:risk.req_remove_investors_from_group.riskgroupid)
  
  return riskgroupid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void req_remove_investors_from_group::set_allocated_riskgroupid(::std::string* riskgroupid) {
  if (riskgroupid != NULL) {
    
  } else {
    
  }
  riskgroupid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), riskgroupid);
  // @@protoc_insertion_point(field_set_allocated:risk.req_remove_investors_from_group.riskgroupid)
}

// repeated string investor = 4;
inline int req_remove_investors_from_group::investor_size() const {
  return investor_.size();
}
inline void req_remove_investors_from_group::clear_investor() {
  investor_.Clear();
}
inline const ::std::string& req_remove_investors_from_group::investor(int index) const {
  // @@protoc_insertion_point(field_get:risk.req_remove_investors_from_group.investor)
  return investor_.Get(index);
}
inline ::std::string* req_remove_investors_from_group::mutable_investor(int index) {
  // @@protoc_insertion_point(field_mutable:risk.req_remove_investors_from_group.investor)
  return investor_.Mutable(index);
}
inline void req_remove_investors_from_group::set_investor(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.req_remove_investors_from_group.investor)
  investor_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void req_remove_investors_from_group::set_investor(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.req_remove_investors_from_group.investor)
  investor_.Mutable(index)->assign(std::move(value));
}
#endif
inline void req_remove_investors_from_group::set_investor(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.req_remove_investors_from_group.investor)
}
inline void req_remove_investors_from_group::set_investor(int index, const char* value, size_t size) {
  investor_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.req_remove_investors_from_group.investor)
}
inline ::std::string* req_remove_investors_from_group::add_investor() {
  // @@protoc_insertion_point(field_add_mutable:risk.req_remove_investors_from_group.investor)
  return investor_.Add();
}
inline void req_remove_investors_from_group::add_investor(const ::std::string& value) {
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.req_remove_investors_from_group.investor)
}
#if LANG_CXX11
inline void req_remove_investors_from_group::add_investor(::std::string&& value) {
  investor_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.req_remove_investors_from_group.investor)
}
#endif
inline void req_remove_investors_from_group::add_investor(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  investor_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.req_remove_investors_from_group.investor)
}
inline void req_remove_investors_from_group::add_investor(const char* value, size_t size) {
  investor_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.req_remove_investors_from_group.investor)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
req_remove_investors_from_group::investor() const {
  // @@protoc_insertion_point(field_list:risk.req_remove_investors_from_group.investor)
  return investor_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
req_remove_investors_from_group::mutable_investor() {
  // @@protoc_insertion_point(field_mutable_list:risk.req_remove_investors_from_group.investor)
  return &investor_;
}

// -------------------------------------------------------------------

// sub_option_position_risk

// int32 model = 1;
inline void sub_option_position_risk::clear_model() {
  model_ = 0;
}
inline ::google::protobuf::int32 sub_option_position_risk::model() const {
  // @@protoc_insertion_point(field_get:risk.sub_option_position_risk.model)
  return model_;
}
inline void sub_option_position_risk::set_model(::google::protobuf::int32 value) {
  
  model_ = value;
  // @@protoc_insertion_point(field_set:risk.sub_option_position_risk.model)
}

// repeated string instrument = 2;
inline int sub_option_position_risk::instrument_size() const {
  return instrument_.size();
}
inline void sub_option_position_risk::clear_instrument() {
  instrument_.Clear();
}
inline const ::std::string& sub_option_position_risk::instrument(int index) const {
  // @@protoc_insertion_point(field_get:risk.sub_option_position_risk.instrument)
  return instrument_.Get(index);
}
inline ::std::string* sub_option_position_risk::mutable_instrument(int index) {
  // @@protoc_insertion_point(field_mutable:risk.sub_option_position_risk.instrument)
  return instrument_.Mutable(index);
}
inline void sub_option_position_risk::set_instrument(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.sub_option_position_risk.instrument)
  instrument_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void sub_option_position_risk::set_instrument(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.sub_option_position_risk.instrument)
  instrument_.Mutable(index)->assign(std::move(value));
}
#endif
inline void sub_option_position_risk::set_instrument(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  instrument_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.sub_option_position_risk.instrument)
}
inline void sub_option_position_risk::set_instrument(int index, const char* value, size_t size) {
  instrument_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.sub_option_position_risk.instrument)
}
inline ::std::string* sub_option_position_risk::add_instrument() {
  // @@protoc_insertion_point(field_add_mutable:risk.sub_option_position_risk.instrument)
  return instrument_.Add();
}
inline void sub_option_position_risk::add_instrument(const ::std::string& value) {
  instrument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.sub_option_position_risk.instrument)
}
#if LANG_CXX11
inline void sub_option_position_risk::add_instrument(::std::string&& value) {
  instrument_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.sub_option_position_risk.instrument)
}
#endif
inline void sub_option_position_risk::add_instrument(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  instrument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.sub_option_position_risk.instrument)
}
inline void sub_option_position_risk::add_instrument(const char* value, size_t size) {
  instrument_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.sub_option_position_risk.instrument)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
sub_option_position_risk::instrument() const {
  // @@protoc_insertion_point(field_list:risk.sub_option_position_risk.instrument)
  return instrument_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
sub_option_position_risk::mutable_instrument() {
  // @@protoc_insertion_point(field_mutable_list:risk.sub_option_position_risk.instrument)
  return &instrument_;
}

// -------------------------------------------------------------------

// unsub_option_position_risk

// int32 model = 1;
inline void unsub_option_position_risk::clear_model() {
  model_ = 0;
}
inline ::google::protobuf::int32 unsub_option_position_risk::model() const {
  // @@protoc_insertion_point(field_get:risk.unsub_option_position_risk.model)
  return model_;
}
inline void unsub_option_position_risk::set_model(::google::protobuf::int32 value) {
  
  model_ = value;
  // @@protoc_insertion_point(field_set:risk.unsub_option_position_risk.model)
}

// repeated string instrument = 2;
inline int unsub_option_position_risk::instrument_size() const {
  return instrument_.size();
}
inline void unsub_option_position_risk::clear_instrument() {
  instrument_.Clear();
}
inline const ::std::string& unsub_option_position_risk::instrument(int index) const {
  // @@protoc_insertion_point(field_get:risk.unsub_option_position_risk.instrument)
  return instrument_.Get(index);
}
inline ::std::string* unsub_option_position_risk::mutable_instrument(int index) {
  // @@protoc_insertion_point(field_mutable:risk.unsub_option_position_risk.instrument)
  return instrument_.Mutable(index);
}
inline void unsub_option_position_risk::set_instrument(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:risk.unsub_option_position_risk.instrument)
  instrument_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void unsub_option_position_risk::set_instrument(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:risk.unsub_option_position_risk.instrument)
  instrument_.Mutable(index)->assign(std::move(value));
}
#endif
inline void unsub_option_position_risk::set_instrument(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  instrument_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:risk.unsub_option_position_risk.instrument)
}
inline void unsub_option_position_risk::set_instrument(int index, const char* value, size_t size) {
  instrument_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:risk.unsub_option_position_risk.instrument)
}
inline ::std::string* unsub_option_position_risk::add_instrument() {
  // @@protoc_insertion_point(field_add_mutable:risk.unsub_option_position_risk.instrument)
  return instrument_.Add();
}
inline void unsub_option_position_risk::add_instrument(const ::std::string& value) {
  instrument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:risk.unsub_option_position_risk.instrument)
}
#if LANG_CXX11
inline void unsub_option_position_risk::add_instrument(::std::string&& value) {
  instrument_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:risk.unsub_option_position_risk.instrument)
}
#endif
inline void unsub_option_position_risk::add_instrument(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  instrument_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:risk.unsub_option_position_risk.instrument)
}
inline void unsub_option_position_risk::add_instrument(const char* value, size_t size) {
  instrument_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:risk.unsub_option_position_risk.instrument)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
unsub_option_position_risk::instrument() const {
  // @@protoc_insertion_point(field_list:risk.unsub_option_position_risk.instrument)
  return instrument_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
unsub_option_position_risk::mutable_instrument() {
  // @@protoc_insertion_point(field_mutable_list:risk.unsub_option_position_risk.instrument)
  return &instrument_;
}

// -------------------------------------------------------------------

// req_whatif

// int32 requestid = 1;
inline void req_whatif::clear_requestid() {
  requestid_ = 0;
}
inline ::google::protobuf::int32 req_whatif::requestid() const {
  // @@protoc_insertion_point(field_get:risk.req_whatif.requestid)
  return requestid_;
}
inline void req_whatif::set_requestid(::google::protobuf::int32 value) {
  
  requestid_ = value;
  // @@protoc_insertion_point(field_set:risk.req_whatif.requestid)
}

// int32 type = 2;
inline void req_whatif::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 req_whatif::type() const {
  // @@protoc_insertion_point(field_get:risk.req_whatif.type)
  return type_;
}
inline void req_whatif::set_type(::google::protobuf::int32 value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:risk.req_whatif.type)
}

// int32 model = 3;
inline void req_whatif::clear_model() {
  model_ = 0;
}
inline ::google::protobuf::int32 req_whatif::model() const {
  // @@protoc_insertion_point(field_get:risk.req_whatif.model)
  return model_;
}
inline void req_whatif::set_model(::google::protobuf::int32 value) {
  
  model_ = value;
  // @@protoc_insertion_point(field_set:risk.req_whatif.model)
}

// string instrument = 4;
inline void req_whatif::clear_instrument() {
  instrument_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& req_whatif::instrument() const {
  // @@protoc_insertion_point(field_get:risk.req_whatif.instrument)
  return instrument_.GetNoArena();
}
inline void req_whatif::set_instrument(const ::std::string& value) {
  
  instrument_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:risk.req_whatif.instrument)
}
#if LANG_CXX11
inline void req_whatif::set_instrument(::std::string&& value) {
  
  instrument_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:risk.req_whatif.instrument)
}
#endif
inline void req_whatif::set_instrument(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  instrument_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:risk.req_whatif.instrument)
}
inline void req_whatif::set_instrument(const char* value, size_t size) {
  
  instrument_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:risk.req_whatif.instrument)
}
inline ::std::string* req_whatif::mutable_instrument() {
  
  // @@protoc_insertion_point(field_mutable:risk.req_whatif.instrument)
  return instrument_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* req_whatif::release_instrument() {
  // @@protoc_insertion_point(field_release:risk.req_whatif.instrument)
  
  return instrument_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void req_whatif::set_allocated_instrument(::std::string* instrument) {
  if (instrument != NULL) {
    
  } else {
    
  }
  instrument_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), instrument);
  // @@protoc_insertion_point(field_set_allocated:risk.req_whatif.instrument)
}

// double range = 5;
inline void req_whatif::clear_range() {
  range_ = 0;
}
inline double req_whatif::range() const {
  // @@protoc_insertion_point(field_get:risk.req_whatif.range)
  return range_;
}
inline void req_whatif::set_range(double value) {
  
  range_ = value;
  // @@protoc_insertion_point(field_set:risk.req_whatif.range)
}

// double base_value = 6;
inline void req_whatif::clear_base_value() {
  base_value_ = 0;
}
inline double req_whatif::base_value() const {
  // @@protoc_insertion_point(field_get:risk.req_whatif.base_value)
  return base_value_;
}
inline void req_whatif::set_base_value(double value) {
  
  base_value_ = value;
  // @@protoc_insertion_point(field_set:risk.req_whatif.base_value)
}

// -------------------------------------------------------------------

// req_option_argv

// int32 requestid = 1;
inline void req_option_argv::clear_requestid() {
  requestid_ = 0;
}
inline ::google::protobuf::int32 req_option_argv::requestid() const {
  // @@protoc_insertion_point(field_get:risk.req_option_argv.requestid)
  return requestid_;
}
inline void req_option_argv::set_requestid(::google::protobuf::int32 value) {
  
  requestid_ = value;
  // @@protoc_insertion_point(field_set:risk.req_option_argv.requestid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace risk

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_riskapi_5faction_5fprotocal_2eproto__INCLUDED
